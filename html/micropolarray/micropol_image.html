<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>micropolarray.micropol_image API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>micropolarray.micropol_image</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

from dataclasses import dataclass
from logging import debug, error, info, warning
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import scipy
from astropy.io import fits
from PIL import Image as PILImage

from micropolarray.cameras import Camera, PolarCam
from micropolarray.image import Image
from micropolarray.polarization_functions import AoLP, DoLP, pB
from micropolarray.processing.chen_wan_liang_calibration import ifov_jitcorrect
from micropolarray.processing.congrid import congrid
from micropolarray.processing.demodulation import Demodulator
from micropolarray.processing.demosaic import (
    demosaic,
    merge_polarizations,
    split_polarizations,
)
from micropolarray.processing.nrgf import roi_from_polar
from micropolarray.processing.rebin import micropolarray_rebin
from micropolarray.processing.shift import shift, shift_micropol
from micropolarray.utils import (
    fix_data,
    make_abs_and_create_dir,
    mean_minus_std,
    mean_plus_std,
)


@dataclass
class PolParam:
    &#34;&#34;&#34;Auxiliary class for polarization parameters.

    Members:
        ID (str): parameter identifier
        data (np.array): parameter image as numpy 2D array
        title (str): brief title of the parameter, useful for plotting
        measure_unit (str): initial measure units of the parameter
        fix_data (bool): controls whether data has to be constrained to [0, 4096] interval (not implemented yet)
    &#34;&#34;&#34;

    ID: str
    data: np.ndarray
    title: str
    measure_unit: str
    fix_data: bool


DEFAULT_ANGLES_DIC = None  # sets the micropolarizer orientations with a dictionary {angle : position in superpix 1-&gt;3}


def set_default_angles(angles_dic: dict):
    &#34;&#34;&#34;Sets the default micropolarizer orientations for images.

    Args:
        angles_dic (dict): dictionary {value : pos} where value is the angle in degrees from -90 to 90 and pos is the pixel position in superpixel, from 0 to 3 (position [y, x], fast index x)
    &#34;&#34;&#34;
    global DEFAULT_ANGLES_DIC
    DEFAULT_ANGLES_DIC = angles_dic


class MicropolImage(Image):
    &#34;&#34;&#34;Micro-polarizer array image class. Can be initialized from a 2d array, a list of 1 or more file names (use the boolean keyword averageimages to select if sum or average is taken) or another MicropolImage. Dark and flat micropolarray images can also be provided to automatically correct the result.&#34;&#34;&#34;

    first_call = True  # Avoid repeating messages

    def __init__(
        self,
        initializer: str | np.ndarray | list | MicropolImage,
        angle_dic: dict = None,
        demosaic_mode: str = &#34;adjacent&#34;,
        dark: MicropolImage = None,
        flat: MicropolImage = None,
        averageimages: bool = True,
    ):
        self._is_demodulated = False
        self._is_demosaiced = False
        self._binning = 1
        self._flat_subtracted = False
        self._dark_subtracted = False
        if angle_dic is None:
            global DEFAULT_ANGLES_DIC
            if DEFAULT_ANGLES_DIC is None:
                if MicropolImage.first_call:
                    warning(
                        f&#34;Micropolarizer orientation dictionary defaults to {PolarCam().angle_dic}, set it via set_default_angles(camera)\n&#34;
                    )
                MicropolImage.first_call = False
                DEFAULT_ANGLES_DIC = PolarCam().angle_dic
            angle_dic = DEFAULT_ANGLES_DIC
        self.angle_dic = angle_dic
        self.demosaic_mode = demosaic_mode
        self.demosaiced_images = None

        if type(initializer) is str and len(initializer) &gt; 1:
            self._num_of_images = len(initializer)
        else:
            self._num_of_images = 1
        super().__init__(
            initializer=initializer, averageimages=averageimages
        )  # Call generic Image() constructor

        if (type(initializer) is list) or (type(initializer) is str):
            self._init_micropolimage_from_file(initializer)
        elif type(initializer) is np.ndarray:
            self._init_micropolimage_from_data(initializer)
        elif type(initializer) is MicropolImage:
            self._init_micropolimage_from_image(initializer)

        self._update_stokes_derived_internal_dataclasses()

        # Apply corrections if needed
        if dark is not None:
            self.subtract_dark(dark=dark)
        if flat is not None:
            self.correct_flat(flat=flat)
        elif MicropolImage.first_call:
            warning(&#34;Remember to set dark&#34;)
            MicropolImage.first_call = False

        self.height, self.width = self.data.shape

    def _init_micropolimage_from_file(self, filenames: str):
        self._set_data_and_Stokes(self.data)

    def _init_micropolimage_from_data(self, data: np.array):
        self._set_data_and_Stokes(self.data)
        if self.header is None:
            self.header = self.set_default_header(data)
        else:
            self._update_dims_in_header(self.data)

    def _init_micropolimage_from_image(self, image: MicropolImage):
        self._is_demodulated = image._is_demodulated
        self._is_demosaiced = image._is_demosaiced
        self._binning = image._binning
        self._dark_subtracted = image._dark_subtracted
        self._flat_subtracted = image._flat_subtracted
        self.angle_dic = image.angle_dic
        self.demosaic_mode = image.demosaic_mode

        self.data = image.data
        self.header = image.header
        self.single_pol_subimages = image.single_pol_subimages
        self.demosaiced_images = image.demosaiced_images
        self.Stokes_vec = image.Stokes_vec
        self.polparam_list = image.polparam_list

    # ----------------------------------------------------------------
    # ---------------------- STOKES COMPONENTS -----------------------
    # ----------------------------------------------------------------

    def _update_Stokes_vec(self) -&gt; None:
        if not self._is_demosaiced:
            self.Stokes_vec = self._get_theo_Stokes_vec_components(
                self.single_pol_subimages
            )
        else:
            self.Stokes_vec = self._get_theo_Stokes_vec_components(
                self.demosaiced_images
            )

    def _update_stokes_derived_internal_dataclasses(self) -&gt; None:
        self.I = PolParam(
            &#34;I&#34;, self.Stokes_vec[0], &#34;Stokes I&#34;, &#34;DN&#34;, fix_data=False
        )
        self.Q = PolParam(
            &#34;Q&#34;, self.Stokes_vec[1], &#34;Stokes Q&#34;, &#34;DN&#34;, fix_data=False
        )
        self.U = PolParam(
            &#34;U&#34;, self.Stokes_vec[2], &#34;Stokes U&#34;, &#34;DN&#34;, fix_data=False
        )
        self.pB = PolParam(
            &#34;pB&#34;,
            pB(self.Stokes_vec),
            &#34;Polarized brightness&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )
        self.AoLP = PolParam(
            &#34;AoLP&#34;,
            AoLP(self.Stokes_vec),
            &#34;Angle of linear polarization&#34;,
            &#34;rad&#34;,
            fix_data=False,
        )
        self.DoLP = PolParam(
            &#34;DoLP&#34;,
            DoLP(self.Stokes_vec),
            &#34;Degree of linear polarization&#34;,
            &#34;&#34;,
            fix_data=False,
        )
        self.polparam_list = [
            self.I,
            self.Q,
            self.U,
            self.pB,
            self.AoLP,
            self.DoLP,
        ]

    def demodulate(self, demodulator: Demodulator) -&gt; MicropolImage:
        &#34;&#34;&#34;Returns a MicropolImage with polarization parameters calculated from the demodulation tensor provided.

        Args:
            demodulator (Demodulator): Demodulator object containing the demodulation tensor components (see processing.new_demodulation)

        Raises:
            ValueError: raised if image and demodulator do not have the same dimension, for example in case of different binning

        Returns:
            MicropolImage: copy of the input image with I, Q, U, pB, DoLP, AoLP calculated from the demodulation tensor.
        &#34;&#34;&#34;
        if (self.height, self.width) != (
            demodulator.mij.shape[2],
            demodulator.mij.shape[3],
        ):
            print(demodulator.mij.shape[2], demodulator.mij.shape[3])
            print(self.height, self.width)
            raise ValueError(
                &#34;Image and demodulator do not have the same dimensions, check binning.&#34;
            )
        info(&#34;Demodulating...&#34;)
        demodulated_image = MicropolImage(self)
        demodulated_image.Stokes_vec = (
            demodulated_image._get_Stokes_from_demodulator(demodulator)
        )
        demodulated_image._update_single_pol_subimages()
        demodulated_image._update_stokes_derived_internal_dataclasses()
        demodulated_image._is_demodulated = True

        info(&#34;Image correctly demodulated&#34;)
        return demodulated_image

    def set_data_only(self, data: np.array = None) -&gt; None:
        if data is None:
            data = self.data
        self.data = data
        self.height = data.shape[0]
        self.width = data.shape[1]
        if (data.shape[0] % 2) or (data.shape[1] % 2):
            warning(
                &#34;Odd number of pixels is incompatible&#34;
                &#34; with micropolarizer arrays operations.&#34;
            )
        self._update_single_pol_subimages()
        if self._is_demosaiced:
            self.demosaic()
        self._update_Stokes_vec()
        self._update_stokes_derived_internal_dataclasses()
        if self.header is None:
            self.header = self.set_default_header(data)
        else:
            self._update_dims_in_header(self.data)

    def _set_data_and_Stokes(self, data: np.array = None) -&gt; None:
        &#34;&#34;&#34;Set image data and derived polarization informations, and
        consequently change header.&#34;&#34;&#34;
        if data is None:
            data = self.data
        self.data = data
        if (data.shape[0] % 2) or (data.shape[1] % 2):
            warning(
                &#34;Odd number of pixels is incompatible&#34;
                &#34; with micropolarizer arrays operations.&#34;
            )
        self.height, self.width = data.shape
        self._update_single_pol_subimages()

        if not self._is_demosaiced:
            self.Stokes_vec = self._get_theo_Stokes_vec_components(
                self.single_pol_subimages
            )
            self._update_stokes_derived_internal_dataclasses()
        else:
            self.demosaic()
            self.Stokes_vec = self._get_theo_Stokes_vec_components(
                self.demosaiced_images
            )

    def _update_single_pol_subimages(self) -&gt; None:
        single_pol_subimages = split_polarizations(self.data)

        self.single_pol_subimages = single_pol_subimages
        self.pol0 = PolParam(
            &#34;0&#34;,
            single_pol_subimages[self.angle_dic[0]],
            &#34;0 deg orientation pixels&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )
        self.pol45 = PolParam(
            &#34;45&#34;,
            single_pol_subimages[self.angle_dic[45]],
            &#34;45 deg orientation pixels&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )
        self.pol_45 = PolParam(
            &#34;-45&#34;,
            single_pol_subimages[self.angle_dic[-45]],
            &#34;-45 deg orientation pixels&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )
        self.pol90 = PolParam(
            &#34;90&#34;,
            single_pol_subimages[self.angle_dic[90]],
            &#34;90 deg orientation pixels&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )

    def _get_theo_Stokes_vec_components(self, single_pol_images) -&gt; np.array:
        &#34;&#34;&#34;
        Computes stokes vector components from four polarized images at four angles, angle_dic describes the coupling between
        poled_images_array[i] &lt;--&gt; angle_dic[i]
        Return:
            stokes vector, shape=(3, poled_images.shape[1], poled_images.shape[0])
        &#34;&#34;&#34;
        I = 0.5 * np.sum(single_pol_images, axis=0)
        Q = (
            single_pol_images[self.angle_dic[0]]
            - single_pol_images[self.angle_dic[90]]
        )
        U = (
            single_pol_images[self.angle_dic[45]]
            - single_pol_images[self.angle_dic[-45]]
        )

        S = np.array([I, Q, U], dtype=float)
        return S

    def _get_Stokes_from_demodulator(
        self, demodulator: Demodulator
    ) -&gt; np.array:
        &#34;&#34;&#34;
        Computes stokes vector components from four polarized images at four angles, angle_dic describes the coupling between
        poled_images_array[i] &lt;--&gt; angle_dic[i]. Assumes:

        I = M_00 * I_1 + M_01 * I_2 + M_02 * I_3 + M_03 * I_4
        Q = M_10 * I_1 + M_11 * I_2 + M_12 * I_3 + M_13 * I_4
        U = M_20 * I_1 + M_21 * I_2 + M_22 * I_3 + M_23 * I_4

        Return:
            stokes vector, shape=(3, poled_images.shape[1], poled_images.shape[0])
        &#34;&#34;&#34;
        # Corrected with demodulation matrices, S.shape = (4, n, m)
        num_of_malus_parameters = 3  # 3 multiplication params
        pixels_in_superpix = 4
        mij = demodulator.mij

        self.demosaic()
        demosaiced_images = self.demosaiced_images
        # demosaiced_images = demosaic(self.data, self.demosaic_mode)

        # IMG = np.array(
        #    [
        #        demosaiced_images[self.angle_dic[0]],
        #        demosaiced_images[self.angle_dic[45]],
        #        demosaiced_images[self.angle_dic[-45]],
        #        demosaiced_images[self.angle_dic[90]],
        #    ],
        #    dtype=float,
        # )  # Liberatore article/thesis

        IMG = np.array(
            [demo_image for demo_image in demosaiced_images],
            dtype=float,
        )
        if (mij[0, 0].shape[0] != IMG[0].shape[0]) or (
            mij[0, 0].shape[1] != IMG[0].shape[1]
        ):
            raise ValueError(
                f&#34;demodulation matrix and demosaiced images have different shape {mij[0,0].shape} {IMG[0].shape}. Check that binning is correct.&#34;
            )  # sanity check

        T_ij = np.zeros(
            shape=(
                num_of_malus_parameters,
                pixels_in_superpix,
                *self.data.shape,
            )
        )
        for i in range(num_of_malus_parameters):
            for j in range(pixels_in_superpix):
                temp_tij = np.multiply(
                    demodulator.mij[i, j, :, :], IMG[j, :, :]
                )  # Matrix product
                T_ij[i, j, :, :] = temp_tij

        I = T_ij[0, 0] + T_ij[0, 1] + T_ij[0, 2] + T_ij[0, 3]
        Q = T_ij[1, 0] + T_ij[1, 1] + T_ij[1, 2] + T_ij[1, 3]
        U = T_ij[2, 0] + T_ij[2, 1] + T_ij[2, 2] + T_ij[2, 3]

        S = np.array([I, Q, U], dtype=float)
        return S

    def subtract_dark(self, dark: MicropolImage) -&gt; MicropolImage:
        &#34;&#34;&#34;Correctly subtracts the input dark image from the image

        Args:
            dark (MicropolImage): dark to subtract

        Returns:
            MicropolImage: copy of input image with dark subtracted
        &#34;&#34;&#34;
        self.data = self.data - dark.data
        self.data = np.where(self.data &gt;= 0, self.data, 0)  # Fix data
        self._set_data_and_Stokes()
        self._dark_subtracted = True
        return self

    def correct_flat(self, flat: MicropolImage) -&gt; MicropolImage:
        &#34;&#34;&#34;Normalizes the flat and uses it to correct the image.

        Args:
            flat (MicropolImage): flat image, does not need to be normalized.

        Returns:
            MicropolImage: copy of input image corrected by flat
        &#34;&#34;&#34;
        normalized_flat = flat.data / np.max(flat.data)

        self.data = np.divide(
            self.data,
            normalized_flat,
            where=normalized_flat != 0.0,
        )

        # self.data = np.where(self.data &gt;= 0, self.data, 0)
        # self.data = np.where(self.data &lt; 4096, self.data, 4096)
        self._set_data_and_Stokes()
        self._flat_subtracted = True
        return self

    def correct_ifov(self) -&gt; MicropolImage:
        &#34;&#34;&#34;Corrects differences in single pixels fields of view inside each superpixel

        Returns:
            MicropolImage: image with data corrected for field of view differences
        &#34;&#34;&#34;
        corrected_data = self.data.copy()
        corrected_data = ifov_jitcorrect(self.data, self.height, self.width)
        self._set_data_and_Stokes(corrected_data)
        return self

    # ----------------------------------------------------------------
    # ------------------------------ SHOW ----------------------------
    # ----------------------------------------------------------------

    def show_with_pol_params(self, cmap=&#34;Greys_r&#34;) -&gt; tuple:
        &#34;&#34;&#34;Returns a fig for each set of image parameters. User must call
        plt.show after this is called.
        Returned parameters:
        - Original image
        - Stokes vector I, Q, U
        - Angle, degree of linear polarizaimagetion Polarized brightness


        Args:
            cmap (str, optional): colormap string. Defaults to &#34;Greys_r&#34;.

        Returns:
            tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots for the image data and another for the six polarization parameters
        &#34;&#34;&#34;
        data_ratio = self.data.shape[0] / self.data.shape[1]
        image_fig, imageax = plt.subplots(dpi=200, constrained_layout=True)
        mappable = imageax.imshow(
            self.data,
            cmap=cmap,
            vmin=mean_minus_std(self.data),
            vmax=mean_plus_std(self.data),
        )
        avg = np.mean(self.data)
        stdev = np.std(self.data)
        imageax.set_title(
            f&#34;Image data (avrg {avg:3.2f}+-{stdev:3.2f})&#34;,
            color=&#34;black&#34;,
        )
        imageax.set_xlabel(&#34;x [px]&#34;)
        imageax.set_ylabel(&#34;y [px]&#34;)
        image_fig.colorbar(
            mappable, ax=imageax, label=&#34;[DN]&#34;, fraction=data_ratio * 0.05
        )
        stokes_fig, stokesax = plt.subplots(
            2, 3, figsize=(14, 9), constrained_layout=True
        )

        stokesax = stokesax.ravel()
        for i, stokes in enumerate(stokesax):
            vmin = mean_minus_std(self.polparam_list[i].data)
            vmax = mean_plus_std(self.polparam_list[i].data)
            avg = np.mean(self.polparam_list[i].data)
            stdev = np.std(self.polparam_list[i].data)
            mappable_stokes = stokes.imshow(
                self.polparam_list[i].data, cmap=cmap, vmin=vmin, vmax=vmax
            )
            stokes.set_title(
                self.polparam_list[i].title
                + f&#34; (avrg {avg:3.2f}+-{stdev:3.2f})&#34;,
                color=&#34;black&#34;,
            )
            stokes.set_xlabel(&#34;x [px]&#34;)
            stokes.set_ylabel(&#34;y [px]&#34;)
            stokes_fig.colorbar(
                mappable_stokes,
                ax=stokes,
                label=self.polparam_list[i].measure_unit,
                fraction=data_ratio * 0.05,
            )
        return image_fig, imageax, stokes_fig, stokesax

    def show_single_pol_images(self, cmap=&#34;Greys_r&#34;):
        &#34;&#34;&#34;Plots the four polarizations images.

        Args:
            cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

        Returns:
            tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
        &#34;&#34;&#34;
        data_ratio = self.data.shape[0] / self.data.shape[1]
        fig, ax = plt.subplots(2, 2, figsize=(9, 9), constrained_layout=True)
        ax = ax.ravel()
        polslist = [self.pol0, self.pol45, self.pol90, self.pol_45]
        for i, singlepolax in enumerate(ax):
            mappable = singlepolax.imshow(polslist[i].data, cmap=cmap)
            singlepolax.set_title(polslist[i].title)
            singlepolax.set_xlabel(&#34;x [px]&#34;)
            singlepolax.set_ylabel(&#34;y [px]&#34;)
            fig.colorbar(
                mappable,
                ax=singlepolax,
                label=polslist[i].measure_unit,
                fraction=data_ratio * 0.05,
                pad=0.01,
            )
        return fig, ax

    def show_demo_images(self, cmap=&#34;Greys_r&#34;):
        &#34;&#34;&#34;Plots the four demosaiced images.

        Args:
            cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

        Returns:
            tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
        &#34;&#34;&#34;
        if not self._is_demosaiced:
            error(&#34;Image is not yet demosaiced.&#34;)
        data_ratio = self.data.shape[0] / self.data.shape[1]
        fig, ax = plt.subplots(2, 2, figsize=(9, 9), constrained_layout=True)
        ax = ax.ravel()
        demo_images_list = self.demosaiced_images
        for i, single_demo_ax in enumerate(ax):
            mappable = single_demo_ax.imshow(
                demo_images_list[i],
                cmap=cmap,
                vmin=mean_minus_std(demo_images_list[i]),
                vmax=mean_plus_std(demo_images_list[i]),
            )
            single_demo_ax.set_title(
                f&#34;Demosaiced image {list(self.angle_dic.keys())[list(self.angle_dic.values()).index(i)]}&#34;
            )
            single_demo_ax.set_xlabel(&#34;x [px]&#34;)
            single_demo_ax.set_ylabel(&#34;y [px]&#34;)
            fig.colorbar(
                mappable,
                ax=single_demo_ax,
                label=&#34;DN&#34;,
                fraction=data_ratio * 0.05,
                pad=0.01,
            )
        return fig, ax

    def show_pol_param(
        self, polparam: PolParam, cmap=&#34;Greys_r&#34;, vmin=None, vmax=None
    ):
        &#34;&#34;&#34;Plots a single polarization parameter given as input

        Args:
            polparam (PolParam): image PolParam containing the parameter to plot. Can be one among [self.I, self.Q, self.U, self.pB, self.AoLP, self.DoLP]
            cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

        Returns:
            tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
        &#34;&#34;&#34;
        data_ratio = self.data.shape[0] / self.data.shape[1]
        fig, ax = plt.subplots(dpi=200)
        if vmin is None:
            vmin = mean_minus_std(polparam.data)
        if vmax is None:
            vmax = mean_plus_std(polparam.data)
        mappable = ax.imshow(
            polparam.data,
            cmap=cmap,
            vmin=vmin,
            vmax=vmax,
        )
        ax.set_title(polparam.title)
        ax.set_xlabel(&#34;x [px]&#34;)
        ax.set_ylabel(&#34;y [px]&#34;)
        fig.colorbar(
            mappable,
            ax=ax,
            label=polparam.measure_unit,
            fraction=data_ratio * 0.05,
        )
        return fig, ax

    # ----------------------------------------------------------------
    # -------------------------- SAVING ------------------------------
    # ----------------------------------------------------------------

    def save_single_pol_images(
        self, filename: str, fixto: list[float, float] = None
    ) -&gt; None:
        &#34;&#34;&#34;Saves the four polarized images as fits files

        Args:
            filename (str): filename of the output image. The four images will be saved as filename_POLXX.fits
            fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

        Raises:
            ValueError: an invalid file name is provided
        &#34;&#34;&#34;
        polslist = [self.pol0, self.pol45, self.pol90, self.pol_45]
        filepath = Path(make_abs_and_create_dir(filename))
        if filepath.suffix != &#34;.fits&#34;:
            raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
        group_filepath = filepath.joinpath(filepath.parent, filepath.stem)
        for single_pol in polslist:
            hdr = self.header.copy()
            hdr[&#34;POL&#34;] = (single_pol.ID, &#34;Micropolarizer orientation&#34;)
            if fixto:
                data = fix_data(single_pol.data, *fixto)
            else:
                data = single_pol.data
            hdu = fits.PrimaryHDU(
                data=data,
                header=hdr,
                do_not_scale_image_data=True,
                uint=False,
            )
            filename_with_ID = str(
                group_filepath.joinpath(
                    str(group_filepath) + &#34;POL&#34; + str(single_pol.ID) + &#34;.fits&#34;
                )
            )
            hdu.writeto(filename_with_ID, overwrite=True)
        info(f&#39;All params successfully saved to &#34;{filename}&#34;&#39;)

    def save_param_as_fits(
        self,
        filename: str,
        polparam: PolParam,
        fixto: list[float, float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Saves chosen polarization parameter as a fits file

        Args:
            filename (str): filename of the output image.
            polparam (PolParam): polarization parameter to save. Can be one among [self.I, self.Q, self.U, self.pB, self.AoLP, self.DoLP]
            fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

        Raises:
            ValueError: filename is not a valid .fits file
        &#34;&#34;&#34;
        filepath = Path(make_abs_and_create_dir(filename))
        if filepath.suffix != &#34;.fits&#34;:
            raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
        hdr = self.header.copy()
        hdr[&#34;PARAM&#34;] = (str(polparam.title), &#34;Polarization parameter&#34;)
        hdr[&#34;UNITS&#34;] = (str(polparam.measure_unit), &#34;Measure units&#34;)
        if fixto:
            data = fix_data(polparam.data, *fixto)
        else:
            data = polparam.data
        hdu = fits.PrimaryHDU(
            data=data,
            header=hdr,
            do_not_scale_image_data=True,
            uint=False,
        )
        filename_with_ID = str(
            filepath.joinpath(
                filepath.parent, filepath.stem + &#34;_&#34; + polparam.ID + &#34;.fits&#34;
            )
        )

        # filename = make_abs_and_create_dir(filename)
        # filename_with_ID = (
        #    filename.split(&#34;.&#34;)[-2] + &#34;_&#34; + polparam.ID + &#34;.fits&#34;
        # )
        hdu.writeto(filename_with_ID, overwrite=True)
        info(f&#39;&#34;{filename_with_ID}&#34; {polparam.ID} successfully saved&#39;)

    def save_all_pol_params_as_fits(self, filename: str) -&gt; None:
        &#34;&#34;&#34;Saves the image and all polarization parameters as fits file with the same name

        Args:
            filename (str): filename of the output image. Will be saved as filename_[I, Q, U, pB, AoLP, DoLP].fits

        Raises:
            ValueError: filename is not a valid .fits file
        &#34;&#34;&#34;
        filepath = Path(filename)
        if filepath.suffix != &#34;.fits&#34;:
            raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
        filepath = Path(make_abs_and_create_dir(filename))
        group_filename = str(filepath.joinpath(filepath.parent, filepath.stem))
        for param in self.polparam_list:
            hdr = self.header.copy()
            hdr[&#34;PARAM&#34;] = (str(param.title), &#34;Polarization parameter&#34;)
            hdr[&#34;UNITS&#34;] = (str(param.measure_unit), &#34;Measure units&#34;)
            if param.fix_data:
                data = fix_data(param.data)
            else:
                data = param.data
            hdu = fits.PrimaryHDU(
                data=data,
                header=hdr,
                do_not_scale_image_data=True,
                uint=False,
            )
            filename_with_ID = group_filename + &#34;_&#34; + param.ID + &#34;.fits&#34;
            hdu.writeto(filename_with_ID, overwrite=True)
        info(f&#39;All params successfully saved to &#34;{group_filename}&#34;&#39;)

    def save_demosaiced_images_as_fits(
        self, filename: str, fixto: list[float, float] = None
    ) -&gt; None:
        &#34;&#34;&#34;Saves the four demosaiced images as fits files

        Args:
            filename (str): filename of the output image. The four images will be saved as filename_POLXX.fits
            fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

        Raises:
            ValueError: an invalid file name is provided
        &#34;&#34;&#34;
        if not self._is_demosaiced:
            raise ValueError(&#34;Demosaiced images not yet calculated.&#34;)
        imageHdr = self.header.copy()
        filepath = Path(filename)
        if not filepath.suffix:
            raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
        filepath = Path(make_abs_and_create_dir(filename))
        group_filename = str(filepath.joinpath(filepath.parent, filepath.stem))
        for i, demo_image in enumerate(self.demosaiced_images):
            POL_ID = list(self.angle_dic.keys())[
                list(self.angle_dic.values()).index(i)
            ]
            imageHdr[&#34;POL&#34;] = (int(POL_ID), &#34;Micropolarizer orientation&#34;)
            if fixto:
                data = fix_data(demo_image, *fixto)
            else:
                data = demo_image
            hdu = fits.PrimaryHDU(
                data=data,
                header=imageHdr,
                do_not_scale_image_data=True,
                uint=False,
            )
            new_filename = group_filename + &#34;_POL&#34; + str(POL_ID) + &#34;.fits&#34;
            hdu.writeto(new_filename, overwrite=True)
        info(
            f&#39;Demosaiced images successfully saved to &#34;{group_filename}_POLX.fits&#34;&#39;
        )

    # ----------------------------------------------------------------
    # -------------------- DATA MANIPULATION -------------------------
    # ----------------------------------------------------------------
    def demosaic(self) -&gt; MicropolImage:
        &#34;&#34;&#34;Returns a demosaiced copy of the image with updated polarization parameters.

        Returns:
            MicropolImage: demosaiced image
        &#34;&#34;&#34;
        self.demosaiced_images = demosaic(self.data, option=self.demosaic_mode)
        self.Stokes_vec = self._get_theo_Stokes_vec_components(
            self.demosaiced_images
        )
        self._update_stokes_derived_internal_dataclasses()
        self._is_demosaiced = True

        return self

    def rebin(self, binning: int) -&gt; MicropolImage:
        &#34;&#34;&#34;Rebins the micropolarizer array image, binned each
        binningxbinning. Sum bins by default.

        Args:
            binning (int): binning to perform. A value of n will be translated in a nxn binning.

        Raises:
            ValueError: negative binning provided

        Returns:
            MicropolImage: copy of the input image, rebinned.
        &#34;&#34;&#34;
        if binning &lt;= 0:
            raise ValueError(f&#34;Negative binning {binning}x{binning}&#34;)
        rebinned_image = MicropolImage(self)
        rebinned_data = micropolarray_rebin(
            np.array(rebinned_image.data, dtype=np.double),
            *rebinned_image.data.shape,
            binning,
        )

        rebinned_image._set_data_and_Stokes(rebinned_data)

        return rebinned_image

    def congrid(self, newdim_y: int, newdim_x: int) -&gt; MicropolImage:
        # Trim to nearest superpixel
        if (newdim_y % 2) or (newdim_x % 2):
            while newdim_y % 2:
                newdim_y = newdim_y - 1
            while newdim_x % 2:
                newdim_x = newdim_x - 1
            warning(
                f&#34;New dimension was incompatible with superpixels. Trimmed to ({newdim_y}, {newdim_x})&#34;
            )

        new_subdims = [int(newdim_y / 2), int(newdim_x / 2)]
        congridded_pol_images = [0.0] * 4
        for subimage_i, pol_subimage in enumerate(self.single_pol_subimages):
            congridded_pol_images[subimage_i] = congrid(
                pol_subimage, new_subdims
            )

        newdata = np.zeros(shape=(newdim_y, newdim_x))
        for pol_super_y in range(new_subdims[0]):
            for pol_super_x in range(new_subdims[1]):
                newdata[
                    pol_super_y * 2 : pol_super_y * 2 + 2,
                    pol_super_x * 2 : pol_super_x * 2 + 2,
                ] = [
                    [
                        congridded_pol_images[0][pol_super_y, pol_super_x],
                        congridded_pol_images[1][pol_super_y, pol_super_x],
                    ],
                    [
                        congridded_pol_images[2][pol_super_y, pol_super_x],
                        congridded_pol_images[3][pol_super_y, pol_super_x],
                    ],
                ]
        newimage = MicropolImage(newdata)
        return newimage

    def rotate(self, angle: float) -&gt; MicropolImage:
        &#34;&#34;&#34;Rotates an image of angle degrees, counter-clockwise.&#34;&#34;&#34;

        single_pols = split_polarizations(self.data)
        for i in range(4):
            image = PILImage.fromarray(single_pols[i])
            image = image.rotate(angle)
            single_pols[i] = np.asarray(image)
        data = merge_polarizations(single_pols)

        return MicropolImage(data)

    def mask_occulter(
        self,
        y: int = PolarCam().occulter_pos_last[0],
        x: int = PolarCam().occulter_pos_last[1],
        r: int = PolarCam().occulter_pos_last[2],
        overoccult: int = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Masks occulter for all image parameters

        Args:
            y (int, optional): Occulter y position. Defaults to PolarCam().occulter_pos_last[0].
            x (int, optional): Occulter x position. Defaults to PolarCam().occulter_pos_last[1].
            r (int, optional): Occulter radius. Defaults to PolarCam().occulter_pos_last[2].
            overoccult (int, optional): Pixels to overoccult. Defaults to 0.
            camera (_type_, optional): Camera image type. Defaults to PolarCam().

        Returns:
            None
        &#34;&#34;&#34;
        # y, x, r = camera.occulter_pos_last

        r = r + overoccult

        self.data = roi_from_polar(
            self.data,
            (y, x),
            [r, 2 * np.max((self.height, self.width))],
        )
        self.single_pol_subimages = [
            roi_from_polar(
                data,
                (int(y / 2), int(x / 2)),
                [
                    int(r / 2),
                    2 * np.max((int(self.height / 2), int(self.width / 2))),
                ],
            )
            for data in self.single_pol_subimages
        ]
        self._update_single_pol_subimages()  # Updates polparam-like
        if self._is_demosaiced:
            self.demosaiced_images = [
                roi_from_polar(
                    data,
                    (y, x),
                    (r, 2 * np.max([self.height, self.width])),
                )
                for data in self.demosaiced_images
            ]
        for param in self.polparam_list:
            ratio = param.data.shape[0] / self.data.shape[0]
            param.data = roi_from_polar(
                param.data,
                (
                    int(y * ratio),
                    int(x * ratio),
                ),
                [
                    int(r * ratio),
                    2 * np.max((param.data.shape[0], param.data.shape[0])),
                ],
            )

    def shift(self, y: int, x: int) -&gt; MicropolImage:
        &#34;&#34;&#34;Shifts image by y, x pixels and fills with 0 the remaining space. Positive numbers for up/right shift and negative for down/left shift. Image is split into polarizations, each one is shifted, then they are merged again.

        Args:
            y (int): vertical shift in pix
            x (int): horizontal shift in pix

        Returns:
            MicropolImage: shifted image copied from the original
        &#34;&#34;&#34;
        # newdata = shift(self.data, y, x)
        newdata = shift_micropol(self.data, y, x)
        newimage = MicropolImage(self)
        newimage._set_data_and_Stokes(newdata)

        return newimage

    def clean_hot_pixels(self, flagged_hot_pix_map: MicropolImage):
        &#34;&#34;&#34;Returns a copy of the image with gaussian smeared pixels where flagged_hot_pix_map == 1.

        Args:
            flagged_hot_pix_map (MicropolImage): hot pixels map.

        Returns:
            MicropolImage: copy of the original image, gaussian smeared where flagged_hot_pix_map == 1
        &#34;&#34;&#34;
        subimages = self.single_pol_subimages
        blurred_subimages = np.array(
            [
                scipy.ndimage.median_filter(subimage, size=2)
                for subimage in subimages
            ]
        )
        flagged_subimages = flagged_hot_pix_map.single_pol_subimages
        subimages = np.where(
            flagged_subimages == 1, blurred_subimages, subimages
        )

        newimage = MicropolImage(self)
        newimage._set_data_and_Stokes(merge_polarizations(subimages))
        return newimage

    # ----------------------------------------------------------------
    # ------------------------ OVERLOADING ---------------------------
    # ----------------------------------------------------------------
    def __add__(self, second) -&gt; MicropolImage:
        if type(self) is type(second):
            newdata = self.data + second.data
            newimage = MicropolImage(self)
            newimage._set_data_and_Stokes(newdata)
            return newimage
        else:
            newdata = self.data + second
            return MicropolImage(newdata, angle_dic=self.angle_dic)

    def __sub__(self, second) -&gt; MicropolImage:
        if type(self) is type(second):
            newdata = self.data - second.data
            newimage = MicropolImage(self)
            newimage._set_data_and_Stokes(newdata)
            return newimage
        else:
            newdata = self.data - second
            return MicropolImage(newdata, angle_dic=self.angle_dic)

    def __mul__(self, second) -&gt; MicropolImage:
        if type(self) is type(second):
            newdata = self.data * second.data
            newimage = MicropolImage(self)
            newimage._set_data_and_Stokes(newdata)
            return newimage
        else:
            newdata = self.data * second
            return MicropolImage(newdata, angle_dic=self.angle_dic)

    def __truediv__(self, second) -&gt; MicropolImage:
        if type(self) is type(second):
            newdata = np.divide(
                self.data, second.data, where=second.data != 0.0
            )
            newimage = MicropolImage(self)
            newimage._set_data_and_Stokes(newdata)
            return newimage
        else:
            # newdata = np.where(second != 0, self.data / second, 4096)
            newdata = np.divide(self.data, second, where=second != 0.0)
            return MicropolImage(newdata, angle_dic=self.angle_dic)


# provide shorter aliases
# PolarcamImage = MicropolImage
# MicropolImage = MicropolImage</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="micropolarray.micropol_image.set_default_angles"><code class="name flex">
<span>def <span class="ident">set_default_angles</span></span>(<span>angles_dic: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the default micropolarizer orientations for images.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angles_dic</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary {value : pos} where value is the angle in degrees from -90 to 90 and pos is the pixel position in superpixel, from 0 to 3 (position [y, x], fast index x)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_angles(angles_dic: dict):
    &#34;&#34;&#34;Sets the default micropolarizer orientations for images.

    Args:
        angles_dic (dict): dictionary {value : pos} where value is the angle in degrees from -90 to 90 and pos is the pixel position in superpixel, from 0 to 3 (position [y, x], fast index x)
    &#34;&#34;&#34;
    global DEFAULT_ANGLES_DIC
    DEFAULT_ANGLES_DIC = angles_dic</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="micropolarray.micropol_image.MicropolImage"><code class="flex name class">
<span>class <span class="ident">MicropolImage</span></span>
<span>(</span><span>initializer: str | np.ndarray | list | <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a>, angle_dic: dict = None, demosaic_mode: str = 'adjacent', dark: <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a> = None, flat: <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a> = None, averageimages: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Micro-polarizer array image class. Can be initialized from a 2d array, a list of 1 or more file names (use the boolean keyword averageimages to select if sum or average is taken) or another MicropolImage. Dark and flat micropolarray images can also be provided to automatically correct the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MicropolImage(Image):
    &#34;&#34;&#34;Micro-polarizer array image class. Can be initialized from a 2d array, a list of 1 or more file names (use the boolean keyword averageimages to select if sum or average is taken) or another MicropolImage. Dark and flat micropolarray images can also be provided to automatically correct the result.&#34;&#34;&#34;

    first_call = True  # Avoid repeating messages

    def __init__(
        self,
        initializer: str | np.ndarray | list | MicropolImage,
        angle_dic: dict = None,
        demosaic_mode: str = &#34;adjacent&#34;,
        dark: MicropolImage = None,
        flat: MicropolImage = None,
        averageimages: bool = True,
    ):
        self._is_demodulated = False
        self._is_demosaiced = False
        self._binning = 1
        self._flat_subtracted = False
        self._dark_subtracted = False
        if angle_dic is None:
            global DEFAULT_ANGLES_DIC
            if DEFAULT_ANGLES_DIC is None:
                if MicropolImage.first_call:
                    warning(
                        f&#34;Micropolarizer orientation dictionary defaults to {PolarCam().angle_dic}, set it via set_default_angles(camera)\n&#34;
                    )
                MicropolImage.first_call = False
                DEFAULT_ANGLES_DIC = PolarCam().angle_dic
            angle_dic = DEFAULT_ANGLES_DIC
        self.angle_dic = angle_dic
        self.demosaic_mode = demosaic_mode
        self.demosaiced_images = None

        if type(initializer) is str and len(initializer) &gt; 1:
            self._num_of_images = len(initializer)
        else:
            self._num_of_images = 1
        super().__init__(
            initializer=initializer, averageimages=averageimages
        )  # Call generic Image() constructor

        if (type(initializer) is list) or (type(initializer) is str):
            self._init_micropolimage_from_file(initializer)
        elif type(initializer) is np.ndarray:
            self._init_micropolimage_from_data(initializer)
        elif type(initializer) is MicropolImage:
            self._init_micropolimage_from_image(initializer)

        self._update_stokes_derived_internal_dataclasses()

        # Apply corrections if needed
        if dark is not None:
            self.subtract_dark(dark=dark)
        if flat is not None:
            self.correct_flat(flat=flat)
        elif MicropolImage.first_call:
            warning(&#34;Remember to set dark&#34;)
            MicropolImage.first_call = False

        self.height, self.width = self.data.shape

    def _init_micropolimage_from_file(self, filenames: str):
        self._set_data_and_Stokes(self.data)

    def _init_micropolimage_from_data(self, data: np.array):
        self._set_data_and_Stokes(self.data)
        if self.header is None:
            self.header = self.set_default_header(data)
        else:
            self._update_dims_in_header(self.data)

    def _init_micropolimage_from_image(self, image: MicropolImage):
        self._is_demodulated = image._is_demodulated
        self._is_demosaiced = image._is_demosaiced
        self._binning = image._binning
        self._dark_subtracted = image._dark_subtracted
        self._flat_subtracted = image._flat_subtracted
        self.angle_dic = image.angle_dic
        self.demosaic_mode = image.demosaic_mode

        self.data = image.data
        self.header = image.header
        self.single_pol_subimages = image.single_pol_subimages
        self.demosaiced_images = image.demosaiced_images
        self.Stokes_vec = image.Stokes_vec
        self.polparam_list = image.polparam_list

    # ----------------------------------------------------------------
    # ---------------------- STOKES COMPONENTS -----------------------
    # ----------------------------------------------------------------

    def _update_Stokes_vec(self) -&gt; None:
        if not self._is_demosaiced:
            self.Stokes_vec = self._get_theo_Stokes_vec_components(
                self.single_pol_subimages
            )
        else:
            self.Stokes_vec = self._get_theo_Stokes_vec_components(
                self.demosaiced_images
            )

    def _update_stokes_derived_internal_dataclasses(self) -&gt; None:
        self.I = PolParam(
            &#34;I&#34;, self.Stokes_vec[0], &#34;Stokes I&#34;, &#34;DN&#34;, fix_data=False
        )
        self.Q = PolParam(
            &#34;Q&#34;, self.Stokes_vec[1], &#34;Stokes Q&#34;, &#34;DN&#34;, fix_data=False
        )
        self.U = PolParam(
            &#34;U&#34;, self.Stokes_vec[2], &#34;Stokes U&#34;, &#34;DN&#34;, fix_data=False
        )
        self.pB = PolParam(
            &#34;pB&#34;,
            pB(self.Stokes_vec),
            &#34;Polarized brightness&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )
        self.AoLP = PolParam(
            &#34;AoLP&#34;,
            AoLP(self.Stokes_vec),
            &#34;Angle of linear polarization&#34;,
            &#34;rad&#34;,
            fix_data=False,
        )
        self.DoLP = PolParam(
            &#34;DoLP&#34;,
            DoLP(self.Stokes_vec),
            &#34;Degree of linear polarization&#34;,
            &#34;&#34;,
            fix_data=False,
        )
        self.polparam_list = [
            self.I,
            self.Q,
            self.U,
            self.pB,
            self.AoLP,
            self.DoLP,
        ]

    def demodulate(self, demodulator: Demodulator) -&gt; MicropolImage:
        &#34;&#34;&#34;Returns a MicropolImage with polarization parameters calculated from the demodulation tensor provided.

        Args:
            demodulator (Demodulator): Demodulator object containing the demodulation tensor components (see processing.new_demodulation)

        Raises:
            ValueError: raised if image and demodulator do not have the same dimension, for example in case of different binning

        Returns:
            MicropolImage: copy of the input image with I, Q, U, pB, DoLP, AoLP calculated from the demodulation tensor.
        &#34;&#34;&#34;
        if (self.height, self.width) != (
            demodulator.mij.shape[2],
            demodulator.mij.shape[3],
        ):
            print(demodulator.mij.shape[2], demodulator.mij.shape[3])
            print(self.height, self.width)
            raise ValueError(
                &#34;Image and demodulator do not have the same dimensions, check binning.&#34;
            )
        info(&#34;Demodulating...&#34;)
        demodulated_image = MicropolImage(self)
        demodulated_image.Stokes_vec = (
            demodulated_image._get_Stokes_from_demodulator(demodulator)
        )
        demodulated_image._update_single_pol_subimages()
        demodulated_image._update_stokes_derived_internal_dataclasses()
        demodulated_image._is_demodulated = True

        info(&#34;Image correctly demodulated&#34;)
        return demodulated_image

    def set_data_only(self, data: np.array = None) -&gt; None:
        if data is None:
            data = self.data
        self.data = data
        self.height = data.shape[0]
        self.width = data.shape[1]
        if (data.shape[0] % 2) or (data.shape[1] % 2):
            warning(
                &#34;Odd number of pixels is incompatible&#34;
                &#34; with micropolarizer arrays operations.&#34;
            )
        self._update_single_pol_subimages()
        if self._is_demosaiced:
            self.demosaic()
        self._update_Stokes_vec()
        self._update_stokes_derived_internal_dataclasses()
        if self.header is None:
            self.header = self.set_default_header(data)
        else:
            self._update_dims_in_header(self.data)

    def _set_data_and_Stokes(self, data: np.array = None) -&gt; None:
        &#34;&#34;&#34;Set image data and derived polarization informations, and
        consequently change header.&#34;&#34;&#34;
        if data is None:
            data = self.data
        self.data = data
        if (data.shape[0] % 2) or (data.shape[1] % 2):
            warning(
                &#34;Odd number of pixels is incompatible&#34;
                &#34; with micropolarizer arrays operations.&#34;
            )
        self.height, self.width = data.shape
        self._update_single_pol_subimages()

        if not self._is_demosaiced:
            self.Stokes_vec = self._get_theo_Stokes_vec_components(
                self.single_pol_subimages
            )
            self._update_stokes_derived_internal_dataclasses()
        else:
            self.demosaic()
            self.Stokes_vec = self._get_theo_Stokes_vec_components(
                self.demosaiced_images
            )

    def _update_single_pol_subimages(self) -&gt; None:
        single_pol_subimages = split_polarizations(self.data)

        self.single_pol_subimages = single_pol_subimages
        self.pol0 = PolParam(
            &#34;0&#34;,
            single_pol_subimages[self.angle_dic[0]],
            &#34;0 deg orientation pixels&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )
        self.pol45 = PolParam(
            &#34;45&#34;,
            single_pol_subimages[self.angle_dic[45]],
            &#34;45 deg orientation pixels&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )
        self.pol_45 = PolParam(
            &#34;-45&#34;,
            single_pol_subimages[self.angle_dic[-45]],
            &#34;-45 deg orientation pixels&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )
        self.pol90 = PolParam(
            &#34;90&#34;,
            single_pol_subimages[self.angle_dic[90]],
            &#34;90 deg orientation pixels&#34;,
            &#34;DN&#34;,
            fix_data=False,
        )

    def _get_theo_Stokes_vec_components(self, single_pol_images) -&gt; np.array:
        &#34;&#34;&#34;
        Computes stokes vector components from four polarized images at four angles, angle_dic describes the coupling between
        poled_images_array[i] &lt;--&gt; angle_dic[i]
        Return:
            stokes vector, shape=(3, poled_images.shape[1], poled_images.shape[0])
        &#34;&#34;&#34;
        I = 0.5 * np.sum(single_pol_images, axis=0)
        Q = (
            single_pol_images[self.angle_dic[0]]
            - single_pol_images[self.angle_dic[90]]
        )
        U = (
            single_pol_images[self.angle_dic[45]]
            - single_pol_images[self.angle_dic[-45]]
        )

        S = np.array([I, Q, U], dtype=float)
        return S

    def _get_Stokes_from_demodulator(
        self, demodulator: Demodulator
    ) -&gt; np.array:
        &#34;&#34;&#34;
        Computes stokes vector components from four polarized images at four angles, angle_dic describes the coupling between
        poled_images_array[i] &lt;--&gt; angle_dic[i]. Assumes:

        I = M_00 * I_1 + M_01 * I_2 + M_02 * I_3 + M_03 * I_4
        Q = M_10 * I_1 + M_11 * I_2 + M_12 * I_3 + M_13 * I_4
        U = M_20 * I_1 + M_21 * I_2 + M_22 * I_3 + M_23 * I_4

        Return:
            stokes vector, shape=(3, poled_images.shape[1], poled_images.shape[0])
        &#34;&#34;&#34;
        # Corrected with demodulation matrices, S.shape = (4, n, m)
        num_of_malus_parameters = 3  # 3 multiplication params
        pixels_in_superpix = 4
        mij = demodulator.mij

        self.demosaic()
        demosaiced_images = self.demosaiced_images
        # demosaiced_images = demosaic(self.data, self.demosaic_mode)

        # IMG = np.array(
        #    [
        #        demosaiced_images[self.angle_dic[0]],
        #        demosaiced_images[self.angle_dic[45]],
        #        demosaiced_images[self.angle_dic[-45]],
        #        demosaiced_images[self.angle_dic[90]],
        #    ],
        #    dtype=float,
        # )  # Liberatore article/thesis

        IMG = np.array(
            [demo_image for demo_image in demosaiced_images],
            dtype=float,
        )
        if (mij[0, 0].shape[0] != IMG[0].shape[0]) or (
            mij[0, 0].shape[1] != IMG[0].shape[1]
        ):
            raise ValueError(
                f&#34;demodulation matrix and demosaiced images have different shape {mij[0,0].shape} {IMG[0].shape}. Check that binning is correct.&#34;
            )  # sanity check

        T_ij = np.zeros(
            shape=(
                num_of_malus_parameters,
                pixels_in_superpix,
                *self.data.shape,
            )
        )
        for i in range(num_of_malus_parameters):
            for j in range(pixels_in_superpix):
                temp_tij = np.multiply(
                    demodulator.mij[i, j, :, :], IMG[j, :, :]
                )  # Matrix product
                T_ij[i, j, :, :] = temp_tij

        I = T_ij[0, 0] + T_ij[0, 1] + T_ij[0, 2] + T_ij[0, 3]
        Q = T_ij[1, 0] + T_ij[1, 1] + T_ij[1, 2] + T_ij[1, 3]
        U = T_ij[2, 0] + T_ij[2, 1] + T_ij[2, 2] + T_ij[2, 3]

        S = np.array([I, Q, U], dtype=float)
        return S

    def subtract_dark(self, dark: MicropolImage) -&gt; MicropolImage:
        &#34;&#34;&#34;Correctly subtracts the input dark image from the image

        Args:
            dark (MicropolImage): dark to subtract

        Returns:
            MicropolImage: copy of input image with dark subtracted
        &#34;&#34;&#34;
        self.data = self.data - dark.data
        self.data = np.where(self.data &gt;= 0, self.data, 0)  # Fix data
        self._set_data_and_Stokes()
        self._dark_subtracted = True
        return self

    def correct_flat(self, flat: MicropolImage) -&gt; MicropolImage:
        &#34;&#34;&#34;Normalizes the flat and uses it to correct the image.

        Args:
            flat (MicropolImage): flat image, does not need to be normalized.

        Returns:
            MicropolImage: copy of input image corrected by flat
        &#34;&#34;&#34;
        normalized_flat = flat.data / np.max(flat.data)

        self.data = np.divide(
            self.data,
            normalized_flat,
            where=normalized_flat != 0.0,
        )

        # self.data = np.where(self.data &gt;= 0, self.data, 0)
        # self.data = np.where(self.data &lt; 4096, self.data, 4096)
        self._set_data_and_Stokes()
        self._flat_subtracted = True
        return self

    def correct_ifov(self) -&gt; MicropolImage:
        &#34;&#34;&#34;Corrects differences in single pixels fields of view inside each superpixel

        Returns:
            MicropolImage: image with data corrected for field of view differences
        &#34;&#34;&#34;
        corrected_data = self.data.copy()
        corrected_data = ifov_jitcorrect(self.data, self.height, self.width)
        self._set_data_and_Stokes(corrected_data)
        return self

    # ----------------------------------------------------------------
    # ------------------------------ SHOW ----------------------------
    # ----------------------------------------------------------------

    def show_with_pol_params(self, cmap=&#34;Greys_r&#34;) -&gt; tuple:
        &#34;&#34;&#34;Returns a fig for each set of image parameters. User must call
        plt.show after this is called.
        Returned parameters:
        - Original image
        - Stokes vector I, Q, U
        - Angle, degree of linear polarizaimagetion Polarized brightness


        Args:
            cmap (str, optional): colormap string. Defaults to &#34;Greys_r&#34;.

        Returns:
            tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots for the image data and another for the six polarization parameters
        &#34;&#34;&#34;
        data_ratio = self.data.shape[0] / self.data.shape[1]
        image_fig, imageax = plt.subplots(dpi=200, constrained_layout=True)
        mappable = imageax.imshow(
            self.data,
            cmap=cmap,
            vmin=mean_minus_std(self.data),
            vmax=mean_plus_std(self.data),
        )
        avg = np.mean(self.data)
        stdev = np.std(self.data)
        imageax.set_title(
            f&#34;Image data (avrg {avg:3.2f}+-{stdev:3.2f})&#34;,
            color=&#34;black&#34;,
        )
        imageax.set_xlabel(&#34;x [px]&#34;)
        imageax.set_ylabel(&#34;y [px]&#34;)
        image_fig.colorbar(
            mappable, ax=imageax, label=&#34;[DN]&#34;, fraction=data_ratio * 0.05
        )
        stokes_fig, stokesax = plt.subplots(
            2, 3, figsize=(14, 9), constrained_layout=True
        )

        stokesax = stokesax.ravel()
        for i, stokes in enumerate(stokesax):
            vmin = mean_minus_std(self.polparam_list[i].data)
            vmax = mean_plus_std(self.polparam_list[i].data)
            avg = np.mean(self.polparam_list[i].data)
            stdev = np.std(self.polparam_list[i].data)
            mappable_stokes = stokes.imshow(
                self.polparam_list[i].data, cmap=cmap, vmin=vmin, vmax=vmax
            )
            stokes.set_title(
                self.polparam_list[i].title
                + f&#34; (avrg {avg:3.2f}+-{stdev:3.2f})&#34;,
                color=&#34;black&#34;,
            )
            stokes.set_xlabel(&#34;x [px]&#34;)
            stokes.set_ylabel(&#34;y [px]&#34;)
            stokes_fig.colorbar(
                mappable_stokes,
                ax=stokes,
                label=self.polparam_list[i].measure_unit,
                fraction=data_ratio * 0.05,
            )
        return image_fig, imageax, stokes_fig, stokesax

    def show_single_pol_images(self, cmap=&#34;Greys_r&#34;):
        &#34;&#34;&#34;Plots the four polarizations images.

        Args:
            cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

        Returns:
            tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
        &#34;&#34;&#34;
        data_ratio = self.data.shape[0] / self.data.shape[1]
        fig, ax = plt.subplots(2, 2, figsize=(9, 9), constrained_layout=True)
        ax = ax.ravel()
        polslist = [self.pol0, self.pol45, self.pol90, self.pol_45]
        for i, singlepolax in enumerate(ax):
            mappable = singlepolax.imshow(polslist[i].data, cmap=cmap)
            singlepolax.set_title(polslist[i].title)
            singlepolax.set_xlabel(&#34;x [px]&#34;)
            singlepolax.set_ylabel(&#34;y [px]&#34;)
            fig.colorbar(
                mappable,
                ax=singlepolax,
                label=polslist[i].measure_unit,
                fraction=data_ratio * 0.05,
                pad=0.01,
            )
        return fig, ax

    def show_demo_images(self, cmap=&#34;Greys_r&#34;):
        &#34;&#34;&#34;Plots the four demosaiced images.

        Args:
            cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

        Returns:
            tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
        &#34;&#34;&#34;
        if not self._is_demosaiced:
            error(&#34;Image is not yet demosaiced.&#34;)
        data_ratio = self.data.shape[0] / self.data.shape[1]
        fig, ax = plt.subplots(2, 2, figsize=(9, 9), constrained_layout=True)
        ax = ax.ravel()
        demo_images_list = self.demosaiced_images
        for i, single_demo_ax in enumerate(ax):
            mappable = single_demo_ax.imshow(
                demo_images_list[i],
                cmap=cmap,
                vmin=mean_minus_std(demo_images_list[i]),
                vmax=mean_plus_std(demo_images_list[i]),
            )
            single_demo_ax.set_title(
                f&#34;Demosaiced image {list(self.angle_dic.keys())[list(self.angle_dic.values()).index(i)]}&#34;
            )
            single_demo_ax.set_xlabel(&#34;x [px]&#34;)
            single_demo_ax.set_ylabel(&#34;y [px]&#34;)
            fig.colorbar(
                mappable,
                ax=single_demo_ax,
                label=&#34;DN&#34;,
                fraction=data_ratio * 0.05,
                pad=0.01,
            )
        return fig, ax

    def show_pol_param(
        self, polparam: PolParam, cmap=&#34;Greys_r&#34;, vmin=None, vmax=None
    ):
        &#34;&#34;&#34;Plots a single polarization parameter given as input

        Args:
            polparam (PolParam): image PolParam containing the parameter to plot. Can be one among [self.I, self.Q, self.U, self.pB, self.AoLP, self.DoLP]
            cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

        Returns:
            tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
        &#34;&#34;&#34;
        data_ratio = self.data.shape[0] / self.data.shape[1]
        fig, ax = plt.subplots(dpi=200)
        if vmin is None:
            vmin = mean_minus_std(polparam.data)
        if vmax is None:
            vmax = mean_plus_std(polparam.data)
        mappable = ax.imshow(
            polparam.data,
            cmap=cmap,
            vmin=vmin,
            vmax=vmax,
        )
        ax.set_title(polparam.title)
        ax.set_xlabel(&#34;x [px]&#34;)
        ax.set_ylabel(&#34;y [px]&#34;)
        fig.colorbar(
            mappable,
            ax=ax,
            label=polparam.measure_unit,
            fraction=data_ratio * 0.05,
        )
        return fig, ax

    # ----------------------------------------------------------------
    # -------------------------- SAVING ------------------------------
    # ----------------------------------------------------------------

    def save_single_pol_images(
        self, filename: str, fixto: list[float, float] = None
    ) -&gt; None:
        &#34;&#34;&#34;Saves the four polarized images as fits files

        Args:
            filename (str): filename of the output image. The four images will be saved as filename_POLXX.fits
            fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

        Raises:
            ValueError: an invalid file name is provided
        &#34;&#34;&#34;
        polslist = [self.pol0, self.pol45, self.pol90, self.pol_45]
        filepath = Path(make_abs_and_create_dir(filename))
        if filepath.suffix != &#34;.fits&#34;:
            raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
        group_filepath = filepath.joinpath(filepath.parent, filepath.stem)
        for single_pol in polslist:
            hdr = self.header.copy()
            hdr[&#34;POL&#34;] = (single_pol.ID, &#34;Micropolarizer orientation&#34;)
            if fixto:
                data = fix_data(single_pol.data, *fixto)
            else:
                data = single_pol.data
            hdu = fits.PrimaryHDU(
                data=data,
                header=hdr,
                do_not_scale_image_data=True,
                uint=False,
            )
            filename_with_ID = str(
                group_filepath.joinpath(
                    str(group_filepath) + &#34;POL&#34; + str(single_pol.ID) + &#34;.fits&#34;
                )
            )
            hdu.writeto(filename_with_ID, overwrite=True)
        info(f&#39;All params successfully saved to &#34;{filename}&#34;&#39;)

    def save_param_as_fits(
        self,
        filename: str,
        polparam: PolParam,
        fixto: list[float, float] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Saves chosen polarization parameter as a fits file

        Args:
            filename (str): filename of the output image.
            polparam (PolParam): polarization parameter to save. Can be one among [self.I, self.Q, self.U, self.pB, self.AoLP, self.DoLP]
            fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

        Raises:
            ValueError: filename is not a valid .fits file
        &#34;&#34;&#34;
        filepath = Path(make_abs_and_create_dir(filename))
        if filepath.suffix != &#34;.fits&#34;:
            raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
        hdr = self.header.copy()
        hdr[&#34;PARAM&#34;] = (str(polparam.title), &#34;Polarization parameter&#34;)
        hdr[&#34;UNITS&#34;] = (str(polparam.measure_unit), &#34;Measure units&#34;)
        if fixto:
            data = fix_data(polparam.data, *fixto)
        else:
            data = polparam.data
        hdu = fits.PrimaryHDU(
            data=data,
            header=hdr,
            do_not_scale_image_data=True,
            uint=False,
        )
        filename_with_ID = str(
            filepath.joinpath(
                filepath.parent, filepath.stem + &#34;_&#34; + polparam.ID + &#34;.fits&#34;
            )
        )

        # filename = make_abs_and_create_dir(filename)
        # filename_with_ID = (
        #    filename.split(&#34;.&#34;)[-2] + &#34;_&#34; + polparam.ID + &#34;.fits&#34;
        # )
        hdu.writeto(filename_with_ID, overwrite=True)
        info(f&#39;&#34;{filename_with_ID}&#34; {polparam.ID} successfully saved&#39;)

    def save_all_pol_params_as_fits(self, filename: str) -&gt; None:
        &#34;&#34;&#34;Saves the image and all polarization parameters as fits file with the same name

        Args:
            filename (str): filename of the output image. Will be saved as filename_[I, Q, U, pB, AoLP, DoLP].fits

        Raises:
            ValueError: filename is not a valid .fits file
        &#34;&#34;&#34;
        filepath = Path(filename)
        if filepath.suffix != &#34;.fits&#34;:
            raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
        filepath = Path(make_abs_and_create_dir(filename))
        group_filename = str(filepath.joinpath(filepath.parent, filepath.stem))
        for param in self.polparam_list:
            hdr = self.header.copy()
            hdr[&#34;PARAM&#34;] = (str(param.title), &#34;Polarization parameter&#34;)
            hdr[&#34;UNITS&#34;] = (str(param.measure_unit), &#34;Measure units&#34;)
            if param.fix_data:
                data = fix_data(param.data)
            else:
                data = param.data
            hdu = fits.PrimaryHDU(
                data=data,
                header=hdr,
                do_not_scale_image_data=True,
                uint=False,
            )
            filename_with_ID = group_filename + &#34;_&#34; + param.ID + &#34;.fits&#34;
            hdu.writeto(filename_with_ID, overwrite=True)
        info(f&#39;All params successfully saved to &#34;{group_filename}&#34;&#39;)

    def save_demosaiced_images_as_fits(
        self, filename: str, fixto: list[float, float] = None
    ) -&gt; None:
        &#34;&#34;&#34;Saves the four demosaiced images as fits files

        Args:
            filename (str): filename of the output image. The four images will be saved as filename_POLXX.fits
            fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

        Raises:
            ValueError: an invalid file name is provided
        &#34;&#34;&#34;
        if not self._is_demosaiced:
            raise ValueError(&#34;Demosaiced images not yet calculated.&#34;)
        imageHdr = self.header.copy()
        filepath = Path(filename)
        if not filepath.suffix:
            raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
        filepath = Path(make_abs_and_create_dir(filename))
        group_filename = str(filepath.joinpath(filepath.parent, filepath.stem))
        for i, demo_image in enumerate(self.demosaiced_images):
            POL_ID = list(self.angle_dic.keys())[
                list(self.angle_dic.values()).index(i)
            ]
            imageHdr[&#34;POL&#34;] = (int(POL_ID), &#34;Micropolarizer orientation&#34;)
            if fixto:
                data = fix_data(demo_image, *fixto)
            else:
                data = demo_image
            hdu = fits.PrimaryHDU(
                data=data,
                header=imageHdr,
                do_not_scale_image_data=True,
                uint=False,
            )
            new_filename = group_filename + &#34;_POL&#34; + str(POL_ID) + &#34;.fits&#34;
            hdu.writeto(new_filename, overwrite=True)
        info(
            f&#39;Demosaiced images successfully saved to &#34;{group_filename}_POLX.fits&#34;&#39;
        )

    # ----------------------------------------------------------------
    # -------------------- DATA MANIPULATION -------------------------
    # ----------------------------------------------------------------
    def demosaic(self) -&gt; MicropolImage:
        &#34;&#34;&#34;Returns a demosaiced copy of the image with updated polarization parameters.

        Returns:
            MicropolImage: demosaiced image
        &#34;&#34;&#34;
        self.demosaiced_images = demosaic(self.data, option=self.demosaic_mode)
        self.Stokes_vec = self._get_theo_Stokes_vec_components(
            self.demosaiced_images
        )
        self._update_stokes_derived_internal_dataclasses()
        self._is_demosaiced = True

        return self

    def rebin(self, binning: int) -&gt; MicropolImage:
        &#34;&#34;&#34;Rebins the micropolarizer array image, binned each
        binningxbinning. Sum bins by default.

        Args:
            binning (int): binning to perform. A value of n will be translated in a nxn binning.

        Raises:
            ValueError: negative binning provided

        Returns:
            MicropolImage: copy of the input image, rebinned.
        &#34;&#34;&#34;
        if binning &lt;= 0:
            raise ValueError(f&#34;Negative binning {binning}x{binning}&#34;)
        rebinned_image = MicropolImage(self)
        rebinned_data = micropolarray_rebin(
            np.array(rebinned_image.data, dtype=np.double),
            *rebinned_image.data.shape,
            binning,
        )

        rebinned_image._set_data_and_Stokes(rebinned_data)

        return rebinned_image

    def congrid(self, newdim_y: int, newdim_x: int) -&gt; MicropolImage:
        # Trim to nearest superpixel
        if (newdim_y % 2) or (newdim_x % 2):
            while newdim_y % 2:
                newdim_y = newdim_y - 1
            while newdim_x % 2:
                newdim_x = newdim_x - 1
            warning(
                f&#34;New dimension was incompatible with superpixels. Trimmed to ({newdim_y}, {newdim_x})&#34;
            )

        new_subdims = [int(newdim_y / 2), int(newdim_x / 2)]
        congridded_pol_images = [0.0] * 4
        for subimage_i, pol_subimage in enumerate(self.single_pol_subimages):
            congridded_pol_images[subimage_i] = congrid(
                pol_subimage, new_subdims
            )

        newdata = np.zeros(shape=(newdim_y, newdim_x))
        for pol_super_y in range(new_subdims[0]):
            for pol_super_x in range(new_subdims[1]):
                newdata[
                    pol_super_y * 2 : pol_super_y * 2 + 2,
                    pol_super_x * 2 : pol_super_x * 2 + 2,
                ] = [
                    [
                        congridded_pol_images[0][pol_super_y, pol_super_x],
                        congridded_pol_images[1][pol_super_y, pol_super_x],
                    ],
                    [
                        congridded_pol_images[2][pol_super_y, pol_super_x],
                        congridded_pol_images[3][pol_super_y, pol_super_x],
                    ],
                ]
        newimage = MicropolImage(newdata)
        return newimage

    def rotate(self, angle: float) -&gt; MicropolImage:
        &#34;&#34;&#34;Rotates an image of angle degrees, counter-clockwise.&#34;&#34;&#34;

        single_pols = split_polarizations(self.data)
        for i in range(4):
            image = PILImage.fromarray(single_pols[i])
            image = image.rotate(angle)
            single_pols[i] = np.asarray(image)
        data = merge_polarizations(single_pols)

        return MicropolImage(data)

    def mask_occulter(
        self,
        y: int = PolarCam().occulter_pos_last[0],
        x: int = PolarCam().occulter_pos_last[1],
        r: int = PolarCam().occulter_pos_last[2],
        overoccult: int = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Masks occulter for all image parameters

        Args:
            y (int, optional): Occulter y position. Defaults to PolarCam().occulter_pos_last[0].
            x (int, optional): Occulter x position. Defaults to PolarCam().occulter_pos_last[1].
            r (int, optional): Occulter radius. Defaults to PolarCam().occulter_pos_last[2].
            overoccult (int, optional): Pixels to overoccult. Defaults to 0.
            camera (_type_, optional): Camera image type. Defaults to PolarCam().

        Returns:
            None
        &#34;&#34;&#34;
        # y, x, r = camera.occulter_pos_last

        r = r + overoccult

        self.data = roi_from_polar(
            self.data,
            (y, x),
            [r, 2 * np.max((self.height, self.width))],
        )
        self.single_pol_subimages = [
            roi_from_polar(
                data,
                (int(y / 2), int(x / 2)),
                [
                    int(r / 2),
                    2 * np.max((int(self.height / 2), int(self.width / 2))),
                ],
            )
            for data in self.single_pol_subimages
        ]
        self._update_single_pol_subimages()  # Updates polparam-like
        if self._is_demosaiced:
            self.demosaiced_images = [
                roi_from_polar(
                    data,
                    (y, x),
                    (r, 2 * np.max([self.height, self.width])),
                )
                for data in self.demosaiced_images
            ]
        for param in self.polparam_list:
            ratio = param.data.shape[0] / self.data.shape[0]
            param.data = roi_from_polar(
                param.data,
                (
                    int(y * ratio),
                    int(x * ratio),
                ),
                [
                    int(r * ratio),
                    2 * np.max((param.data.shape[0], param.data.shape[0])),
                ],
            )

    def shift(self, y: int, x: int) -&gt; MicropolImage:
        &#34;&#34;&#34;Shifts image by y, x pixels and fills with 0 the remaining space. Positive numbers for up/right shift and negative for down/left shift. Image is split into polarizations, each one is shifted, then they are merged again.

        Args:
            y (int): vertical shift in pix
            x (int): horizontal shift in pix

        Returns:
            MicropolImage: shifted image copied from the original
        &#34;&#34;&#34;
        # newdata = shift(self.data, y, x)
        newdata = shift_micropol(self.data, y, x)
        newimage = MicropolImage(self)
        newimage._set_data_and_Stokes(newdata)

        return newimage

    def clean_hot_pixels(self, flagged_hot_pix_map: MicropolImage):
        &#34;&#34;&#34;Returns a copy of the image with gaussian smeared pixels where flagged_hot_pix_map == 1.

        Args:
            flagged_hot_pix_map (MicropolImage): hot pixels map.

        Returns:
            MicropolImage: copy of the original image, gaussian smeared where flagged_hot_pix_map == 1
        &#34;&#34;&#34;
        subimages = self.single_pol_subimages
        blurred_subimages = np.array(
            [
                scipy.ndimage.median_filter(subimage, size=2)
                for subimage in subimages
            ]
        )
        flagged_subimages = flagged_hot_pix_map.single_pol_subimages
        subimages = np.where(
            flagged_subimages == 1, blurred_subimages, subimages
        )

        newimage = MicropolImage(self)
        newimage._set_data_and_Stokes(merge_polarizations(subimages))
        return newimage

    # ----------------------------------------------------------------
    # ------------------------ OVERLOADING ---------------------------
    # ----------------------------------------------------------------
    def __add__(self, second) -&gt; MicropolImage:
        if type(self) is type(second):
            newdata = self.data + second.data
            newimage = MicropolImage(self)
            newimage._set_data_and_Stokes(newdata)
            return newimage
        else:
            newdata = self.data + second
            return MicropolImage(newdata, angle_dic=self.angle_dic)

    def __sub__(self, second) -&gt; MicropolImage:
        if type(self) is type(second):
            newdata = self.data - second.data
            newimage = MicropolImage(self)
            newimage._set_data_and_Stokes(newdata)
            return newimage
        else:
            newdata = self.data - second
            return MicropolImage(newdata, angle_dic=self.angle_dic)

    def __mul__(self, second) -&gt; MicropolImage:
        if type(self) is type(second):
            newdata = self.data * second.data
            newimage = MicropolImage(self)
            newimage._set_data_and_Stokes(newdata)
            return newimage
        else:
            newdata = self.data * second
            return MicropolImage(newdata, angle_dic=self.angle_dic)

    def __truediv__(self, second) -&gt; MicropolImage:
        if type(self) is type(second):
            newdata = np.divide(
                self.data, second.data, where=second.data != 0.0
            )
            newimage = MicropolImage(self)
            newimage._set_data_and_Stokes(newdata)
            return newimage
        else:
            # newdata = np.where(second != 0, self.data / second, 4096)
            newdata = np.divide(self.data, second, where=second != 0.0)
            return MicropolImage(newdata, angle_dic=self.angle_dic)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="micropolarray.image.Image" href="image.html#micropolarray.image.Image">Image</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="micropolarray.micropol_image.MicropolImage.first_call"><code class="name">var <span class="ident">first_call</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="micropolarray.micropol_image.MicropolImage.clean_hot_pixels"><code class="name flex">
<span>def <span class="ident">clean_hot_pixels</span></span>(<span>self, flagged_hot_pix_map: <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the image with gaussian smeared pixels where flagged_hot_pix_map == 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flagged_hot_pix_map</code></strong> :&ensp;<code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>hot pixels map.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>copy of the original image, gaussian smeared where flagged_hot_pix_map == 1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_hot_pixels(self, flagged_hot_pix_map: MicropolImage):
    &#34;&#34;&#34;Returns a copy of the image with gaussian smeared pixels where flagged_hot_pix_map == 1.

    Args:
        flagged_hot_pix_map (MicropolImage): hot pixels map.

    Returns:
        MicropolImage: copy of the original image, gaussian smeared where flagged_hot_pix_map == 1
    &#34;&#34;&#34;
    subimages = self.single_pol_subimages
    blurred_subimages = np.array(
        [
            scipy.ndimage.median_filter(subimage, size=2)
            for subimage in subimages
        ]
    )
    flagged_subimages = flagged_hot_pix_map.single_pol_subimages
    subimages = np.where(
        flagged_subimages == 1, blurred_subimages, subimages
    )

    newimage = MicropolImage(self)
    newimage._set_data_and_Stokes(merge_polarizations(subimages))
    return newimage</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.congrid"><code class="name flex">
<span>def <span class="ident">congrid</span></span>(<span>self, newdim_y: int, newdim_x: int) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def congrid(self, newdim_y: int, newdim_x: int) -&gt; MicropolImage:
    # Trim to nearest superpixel
    if (newdim_y % 2) or (newdim_x % 2):
        while newdim_y % 2:
            newdim_y = newdim_y - 1
        while newdim_x % 2:
            newdim_x = newdim_x - 1
        warning(
            f&#34;New dimension was incompatible with superpixels. Trimmed to ({newdim_y}, {newdim_x})&#34;
        )

    new_subdims = [int(newdim_y / 2), int(newdim_x / 2)]
    congridded_pol_images = [0.0] * 4
    for subimage_i, pol_subimage in enumerate(self.single_pol_subimages):
        congridded_pol_images[subimage_i] = congrid(
            pol_subimage, new_subdims
        )

    newdata = np.zeros(shape=(newdim_y, newdim_x))
    for pol_super_y in range(new_subdims[0]):
        for pol_super_x in range(new_subdims[1]):
            newdata[
                pol_super_y * 2 : pol_super_y * 2 + 2,
                pol_super_x * 2 : pol_super_x * 2 + 2,
            ] = [
                [
                    congridded_pol_images[0][pol_super_y, pol_super_x],
                    congridded_pol_images[1][pol_super_y, pol_super_x],
                ],
                [
                    congridded_pol_images[2][pol_super_y, pol_super_x],
                    congridded_pol_images[3][pol_super_y, pol_super_x],
                ],
            ]
    newimage = MicropolImage(newdata)
    return newimage</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.correct_flat"><code class="name flex">
<span>def <span class="ident">correct_flat</span></span>(<span>self, flat: <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a>) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"><p>Normalizes the flat and uses it to correct the image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flat</code></strong> :&ensp;<code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>flat image, does not need to be normalized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>copy of input image corrected by flat</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_flat(self, flat: MicropolImage) -&gt; MicropolImage:
    &#34;&#34;&#34;Normalizes the flat and uses it to correct the image.

    Args:
        flat (MicropolImage): flat image, does not need to be normalized.

    Returns:
        MicropolImage: copy of input image corrected by flat
    &#34;&#34;&#34;
    normalized_flat = flat.data / np.max(flat.data)

    self.data = np.divide(
        self.data,
        normalized_flat,
        where=normalized_flat != 0.0,
    )

    # self.data = np.where(self.data &gt;= 0, self.data, 0)
    # self.data = np.where(self.data &lt; 4096, self.data, 4096)
    self._set_data_and_Stokes()
    self._flat_subtracted = True
    return self</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.correct_ifov"><code class="name flex">
<span>def <span class="ident">correct_ifov</span></span>(<span>self) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"><p>Corrects differences in single pixels fields of view inside each superpixel</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>image with data corrected for field of view differences</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_ifov(self) -&gt; MicropolImage:
    &#34;&#34;&#34;Corrects differences in single pixels fields of view inside each superpixel

    Returns:
        MicropolImage: image with data corrected for field of view differences
    &#34;&#34;&#34;
    corrected_data = self.data.copy()
    corrected_data = ifov_jitcorrect(self.data, self.height, self.width)
    self._set_data_and_Stokes(corrected_data)
    return self</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.demodulate"><code class="name flex">
<span>def <span class="ident">demodulate</span></span>(<span>self, demodulator: Demodulator) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a MicropolImage with polarization parameters calculated from the demodulation tensor provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>demodulator</code></strong> :&ensp;<code>Demodulator</code></dt>
<dd>Demodulator object containing the demodulation tensor components (see processing.new_demodulation)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>raised if image and demodulator do not have the same dimension, for example in case of different binning</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>copy of the input image with I, Q, U, pB, DoLP, AoLP calculated from the demodulation tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demodulate(self, demodulator: Demodulator) -&gt; MicropolImage:
    &#34;&#34;&#34;Returns a MicropolImage with polarization parameters calculated from the demodulation tensor provided.

    Args:
        demodulator (Demodulator): Demodulator object containing the demodulation tensor components (see processing.new_demodulation)

    Raises:
        ValueError: raised if image and demodulator do not have the same dimension, for example in case of different binning

    Returns:
        MicropolImage: copy of the input image with I, Q, U, pB, DoLP, AoLP calculated from the demodulation tensor.
    &#34;&#34;&#34;
    if (self.height, self.width) != (
        demodulator.mij.shape[2],
        demodulator.mij.shape[3],
    ):
        print(demodulator.mij.shape[2], demodulator.mij.shape[3])
        print(self.height, self.width)
        raise ValueError(
            &#34;Image and demodulator do not have the same dimensions, check binning.&#34;
        )
    info(&#34;Demodulating...&#34;)
    demodulated_image = MicropolImage(self)
    demodulated_image.Stokes_vec = (
        demodulated_image._get_Stokes_from_demodulator(demodulator)
    )
    demodulated_image._update_single_pol_subimages()
    demodulated_image._update_stokes_derived_internal_dataclasses()
    demodulated_image._is_demodulated = True

    info(&#34;Image correctly demodulated&#34;)
    return demodulated_image</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.demosaic"><code class="name flex">
<span>def <span class="ident">demosaic</span></span>(<span>self) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a demosaiced copy of the image with updated polarization parameters.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>demosaiced image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demosaic(self) -&gt; MicropolImage:
    &#34;&#34;&#34;Returns a demosaiced copy of the image with updated polarization parameters.

    Returns:
        MicropolImage: demosaiced image
    &#34;&#34;&#34;
    self.demosaiced_images = demosaic(self.data, option=self.demosaic_mode)
    self.Stokes_vec = self._get_theo_Stokes_vec_components(
        self.demosaiced_images
    )
    self._update_stokes_derived_internal_dataclasses()
    self._is_demosaiced = True

    return self</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.mask_occulter"><code class="name flex">
<span>def <span class="ident">mask_occulter</span></span>(<span>self, y: int = 919, x: int = 950, r: int = 531, overoccult: int = 0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Masks occulter for all image parameters</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Occulter y position. Defaults to PolarCam().occulter_pos_last[0].</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Occulter x position. Defaults to PolarCam().occulter_pos_last[1].</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Occulter radius. Defaults to PolarCam().occulter_pos_last[2].</dd>
<dt><strong><code>overoccult</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Pixels to overoccult. Defaults to 0.</dd>
<dt><strong><code>camera</code></strong> :&ensp;<code>_type_</code>, optional</dt>
<dd>Camera image type. Defaults to PolarCam().</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_occulter(
    self,
    y: int = PolarCam().occulter_pos_last[0],
    x: int = PolarCam().occulter_pos_last[1],
    r: int = PolarCam().occulter_pos_last[2],
    overoccult: int = 0,
) -&gt; None:
    &#34;&#34;&#34;Masks occulter for all image parameters

    Args:
        y (int, optional): Occulter y position. Defaults to PolarCam().occulter_pos_last[0].
        x (int, optional): Occulter x position. Defaults to PolarCam().occulter_pos_last[1].
        r (int, optional): Occulter radius. Defaults to PolarCam().occulter_pos_last[2].
        overoccult (int, optional): Pixels to overoccult. Defaults to 0.
        camera (_type_, optional): Camera image type. Defaults to PolarCam().

    Returns:
        None
    &#34;&#34;&#34;
    # y, x, r = camera.occulter_pos_last

    r = r + overoccult

    self.data = roi_from_polar(
        self.data,
        (y, x),
        [r, 2 * np.max((self.height, self.width))],
    )
    self.single_pol_subimages = [
        roi_from_polar(
            data,
            (int(y / 2), int(x / 2)),
            [
                int(r / 2),
                2 * np.max((int(self.height / 2), int(self.width / 2))),
            ],
        )
        for data in self.single_pol_subimages
    ]
    self._update_single_pol_subimages()  # Updates polparam-like
    if self._is_demosaiced:
        self.demosaiced_images = [
            roi_from_polar(
                data,
                (y, x),
                (r, 2 * np.max([self.height, self.width])),
            )
            for data in self.demosaiced_images
        ]
    for param in self.polparam_list:
        ratio = param.data.shape[0] / self.data.shape[0]
        param.data = roi_from_polar(
            param.data,
            (
                int(y * ratio),
                int(x * ratio),
            ),
            [
                int(r * ratio),
                2 * np.max((param.data.shape[0], param.data.shape[0])),
            ],
        )</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.rebin"><code class="name flex">
<span>def <span class="ident">rebin</span></span>(<span>self, binning: int) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"><p>Rebins the micropolarizer array image, binned each
binningxbinning. Sum bins by default.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binning</code></strong> :&ensp;<code>int</code></dt>
<dd>binning to perform. A value of n will be translated in a nxn binning.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>negative binning provided</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>copy of the input image, rebinned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rebin(self, binning: int) -&gt; MicropolImage:
    &#34;&#34;&#34;Rebins the micropolarizer array image, binned each
    binningxbinning. Sum bins by default.

    Args:
        binning (int): binning to perform. A value of n will be translated in a nxn binning.

    Raises:
        ValueError: negative binning provided

    Returns:
        MicropolImage: copy of the input image, rebinned.
    &#34;&#34;&#34;
    if binning &lt;= 0:
        raise ValueError(f&#34;Negative binning {binning}x{binning}&#34;)
    rebinned_image = MicropolImage(self)
    rebinned_data = micropolarray_rebin(
        np.array(rebinned_image.data, dtype=np.double),
        *rebinned_image.data.shape,
        binning,
    )

    rebinned_image._set_data_and_Stokes(rebinned_data)

    return rebinned_image</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle: float) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"><p>Rotates an image of angle degrees, counter-clockwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, angle: float) -&gt; MicropolImage:
    &#34;&#34;&#34;Rotates an image of angle degrees, counter-clockwise.&#34;&#34;&#34;

    single_pols = split_polarizations(self.data)
    for i in range(4):
        image = PILImage.fromarray(single_pols[i])
        image = image.rotate(angle)
        single_pols[i] = np.asarray(image)
    data = merge_polarizations(single_pols)

    return MicropolImage(data)</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.save_all_pol_params_as_fits"><code class="name flex">
<span>def <span class="ident">save_all_pol_params_as_fits</span></span>(<span>self, filename: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the image and all polarization parameters as fits file with the same name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of the output image. Will be saved as filename_[I, Q, U, pB, AoLP, DoLP].fits</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>filename is not a valid .fits file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_all_pol_params_as_fits(self, filename: str) -&gt; None:
    &#34;&#34;&#34;Saves the image and all polarization parameters as fits file with the same name

    Args:
        filename (str): filename of the output image. Will be saved as filename_[I, Q, U, pB, AoLP, DoLP].fits

    Raises:
        ValueError: filename is not a valid .fits file
    &#34;&#34;&#34;
    filepath = Path(filename)
    if filepath.suffix != &#34;.fits&#34;:
        raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
    filepath = Path(make_abs_and_create_dir(filename))
    group_filename = str(filepath.joinpath(filepath.parent, filepath.stem))
    for param in self.polparam_list:
        hdr = self.header.copy()
        hdr[&#34;PARAM&#34;] = (str(param.title), &#34;Polarization parameter&#34;)
        hdr[&#34;UNITS&#34;] = (str(param.measure_unit), &#34;Measure units&#34;)
        if param.fix_data:
            data = fix_data(param.data)
        else:
            data = param.data
        hdu = fits.PrimaryHDU(
            data=data,
            header=hdr,
            do_not_scale_image_data=True,
            uint=False,
        )
        filename_with_ID = group_filename + &#34;_&#34; + param.ID + &#34;.fits&#34;
        hdu.writeto(filename_with_ID, overwrite=True)
    info(f&#39;All params successfully saved to &#34;{group_filename}&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.save_demosaiced_images_as_fits"><code class="name flex">
<span>def <span class="ident">save_demosaiced_images_as_fits</span></span>(<span>self, filename: str, fixto: list[float, float] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the four demosaiced images as fits files</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of the output image. The four images will be saved as filename_POLXX.fits</dd>
<dt><strong><code>fixto</code></strong> :&ensp;<code>list[float, float]</code>, optional</dt>
<dd>set the minimum and maximum value for the output images. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>an invalid file name is provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_demosaiced_images_as_fits(
    self, filename: str, fixto: list[float, float] = None
) -&gt; None:
    &#34;&#34;&#34;Saves the four demosaiced images as fits files

    Args:
        filename (str): filename of the output image. The four images will be saved as filename_POLXX.fits
        fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

    Raises:
        ValueError: an invalid file name is provided
    &#34;&#34;&#34;
    if not self._is_demosaiced:
        raise ValueError(&#34;Demosaiced images not yet calculated.&#34;)
    imageHdr = self.header.copy()
    filepath = Path(filename)
    if not filepath.suffix:
        raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
    filepath = Path(make_abs_and_create_dir(filename))
    group_filename = str(filepath.joinpath(filepath.parent, filepath.stem))
    for i, demo_image in enumerate(self.demosaiced_images):
        POL_ID = list(self.angle_dic.keys())[
            list(self.angle_dic.values()).index(i)
        ]
        imageHdr[&#34;POL&#34;] = (int(POL_ID), &#34;Micropolarizer orientation&#34;)
        if fixto:
            data = fix_data(demo_image, *fixto)
        else:
            data = demo_image
        hdu = fits.PrimaryHDU(
            data=data,
            header=imageHdr,
            do_not_scale_image_data=True,
            uint=False,
        )
        new_filename = group_filename + &#34;_POL&#34; + str(POL_ID) + &#34;.fits&#34;
        hdu.writeto(new_filename, overwrite=True)
    info(
        f&#39;Demosaiced images successfully saved to &#34;{group_filename}_POLX.fits&#34;&#39;
    )</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.save_param_as_fits"><code class="name flex">
<span>def <span class="ident">save_param_as_fits</span></span>(<span>self, filename: str, polparam: <a title="micropolarray.micropol_image.PolParam" href="#micropolarray.micropol_image.PolParam">PolParam</a>, fixto: list[float, float] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves chosen polarization parameter as a fits file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of the output image.</dd>
<dt><strong><code>polparam</code></strong> :&ensp;<code><a title="micropolarray.micropol_image.PolParam" href="#micropolarray.micropol_image.PolParam">PolParam</a></code></dt>
<dd>polarization parameter to save. Can be one among [self.I, self.Q, self.U, self.pB, self.AoLP, self.DoLP]</dd>
<dt><strong><code>fixto</code></strong> :&ensp;<code>list[float, float]</code>, optional</dt>
<dd>set the minimum and maximum value for the output images. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>filename is not a valid .fits file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_param_as_fits(
    self,
    filename: str,
    polparam: PolParam,
    fixto: list[float, float] = None,
) -&gt; None:
    &#34;&#34;&#34;Saves chosen polarization parameter as a fits file

    Args:
        filename (str): filename of the output image.
        polparam (PolParam): polarization parameter to save. Can be one among [self.I, self.Q, self.U, self.pB, self.AoLP, self.DoLP]
        fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

    Raises:
        ValueError: filename is not a valid .fits file
    &#34;&#34;&#34;
    filepath = Path(make_abs_and_create_dir(filename))
    if filepath.suffix != &#34;.fits&#34;:
        raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
    hdr = self.header.copy()
    hdr[&#34;PARAM&#34;] = (str(polparam.title), &#34;Polarization parameter&#34;)
    hdr[&#34;UNITS&#34;] = (str(polparam.measure_unit), &#34;Measure units&#34;)
    if fixto:
        data = fix_data(polparam.data, *fixto)
    else:
        data = polparam.data
    hdu = fits.PrimaryHDU(
        data=data,
        header=hdr,
        do_not_scale_image_data=True,
        uint=False,
    )
    filename_with_ID = str(
        filepath.joinpath(
            filepath.parent, filepath.stem + &#34;_&#34; + polparam.ID + &#34;.fits&#34;
        )
    )

    # filename = make_abs_and_create_dir(filename)
    # filename_with_ID = (
    #    filename.split(&#34;.&#34;)[-2] + &#34;_&#34; + polparam.ID + &#34;.fits&#34;
    # )
    hdu.writeto(filename_with_ID, overwrite=True)
    info(f&#39;&#34;{filename_with_ID}&#34; {polparam.ID} successfully saved&#39;)</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.save_single_pol_images"><code class="name flex">
<span>def <span class="ident">save_single_pol_images</span></span>(<span>self, filename: str, fixto: list[float, float] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the four polarized images as fits files</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of the output image. The four images will be saved as filename_POLXX.fits</dd>
<dt><strong><code>fixto</code></strong> :&ensp;<code>list[float, float]</code>, optional</dt>
<dd>set the minimum and maximum value for the output images. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>an invalid file name is provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_single_pol_images(
    self, filename: str, fixto: list[float, float] = None
) -&gt; None:
    &#34;&#34;&#34;Saves the four polarized images as fits files

    Args:
        filename (str): filename of the output image. The four images will be saved as filename_POLXX.fits
        fixto (list[float, float], optional): set the minimum and maximum value for the output images. Defaults to None.

    Raises:
        ValueError: an invalid file name is provided
    &#34;&#34;&#34;
    polslist = [self.pol0, self.pol45, self.pol90, self.pol_45]
    filepath = Path(make_abs_and_create_dir(filename))
    if filepath.suffix != &#34;.fits&#34;:
        raise ValueError(&#34;filename must be a valid file name, not folder.&#34;)
    group_filepath = filepath.joinpath(filepath.parent, filepath.stem)
    for single_pol in polslist:
        hdr = self.header.copy()
        hdr[&#34;POL&#34;] = (single_pol.ID, &#34;Micropolarizer orientation&#34;)
        if fixto:
            data = fix_data(single_pol.data, *fixto)
        else:
            data = single_pol.data
        hdu = fits.PrimaryHDU(
            data=data,
            header=hdr,
            do_not_scale_image_data=True,
            uint=False,
        )
        filename_with_ID = str(
            group_filepath.joinpath(
                str(group_filepath) + &#34;POL&#34; + str(single_pol.ID) + &#34;.fits&#34;
            )
        )
        hdu.writeto(filename_with_ID, overwrite=True)
    info(f&#39;All params successfully saved to &#34;{filename}&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.set_data_only"><code class="name flex">
<span>def <span class="ident">set_data_only</span></span>(<span>self, data: np.array = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_data_only(self, data: np.array = None) -&gt; None:
    if data is None:
        data = self.data
    self.data = data
    self.height = data.shape[0]
    self.width = data.shape[1]
    if (data.shape[0] % 2) or (data.shape[1] % 2):
        warning(
            &#34;Odd number of pixels is incompatible&#34;
            &#34; with micropolarizer arrays operations.&#34;
        )
    self._update_single_pol_subimages()
    if self._is_demosaiced:
        self.demosaic()
    self._update_Stokes_vec()
    self._update_stokes_derived_internal_dataclasses()
    if self.header is None:
        self.header = self.set_default_header(data)
    else:
        self._update_dims_in_header(self.data)</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>self, y: int, x: int) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shifts image by y, x pixels and fills with 0 the remaining space. Positive numbers for up/right shift and negative for down/left shift. Image is split into polarizations, each one is shifted, then they are merged again.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>vertical shift in pix</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>horizontal shift in pix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>shifted image copied from the original</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift(self, y: int, x: int) -&gt; MicropolImage:
    &#34;&#34;&#34;Shifts image by y, x pixels and fills with 0 the remaining space. Positive numbers for up/right shift and negative for down/left shift. Image is split into polarizations, each one is shifted, then they are merged again.

    Args:
        y (int): vertical shift in pix
        x (int): horizontal shift in pix

    Returns:
        MicropolImage: shifted image copied from the original
    &#34;&#34;&#34;
    # newdata = shift(self.data, y, x)
    newdata = shift_micropol(self.data, y, x)
    newimage = MicropolImage(self)
    newimage._set_data_and_Stokes(newdata)

    return newimage</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.show_demo_images"><code class="name flex">
<span>def <span class="ident">show_demo_images</span></span>(<span>self, cmap='Greys_r')</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the four demosaiced images.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>colormap for the plot. Defaults to "Greys_r".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>a (figure, axis) couple same as matplotlib.pyplot.subplots</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_demo_images(self, cmap=&#34;Greys_r&#34;):
    &#34;&#34;&#34;Plots the four demosaiced images.

    Args:
        cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

    Returns:
        tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
    &#34;&#34;&#34;
    if not self._is_demosaiced:
        error(&#34;Image is not yet demosaiced.&#34;)
    data_ratio = self.data.shape[0] / self.data.shape[1]
    fig, ax = plt.subplots(2, 2, figsize=(9, 9), constrained_layout=True)
    ax = ax.ravel()
    demo_images_list = self.demosaiced_images
    for i, single_demo_ax in enumerate(ax):
        mappable = single_demo_ax.imshow(
            demo_images_list[i],
            cmap=cmap,
            vmin=mean_minus_std(demo_images_list[i]),
            vmax=mean_plus_std(demo_images_list[i]),
        )
        single_demo_ax.set_title(
            f&#34;Demosaiced image {list(self.angle_dic.keys())[list(self.angle_dic.values()).index(i)]}&#34;
        )
        single_demo_ax.set_xlabel(&#34;x [px]&#34;)
        single_demo_ax.set_ylabel(&#34;y [px]&#34;)
        fig.colorbar(
            mappable,
            ax=single_demo_ax,
            label=&#34;DN&#34;,
            fraction=data_ratio * 0.05,
            pad=0.01,
        )
    return fig, ax</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.show_pol_param"><code class="name flex">
<span>def <span class="ident">show_pol_param</span></span>(<span>self, polparam: <a title="micropolarray.micropol_image.PolParam" href="#micropolarray.micropol_image.PolParam">PolParam</a>, cmap='Greys_r', vmin=None, vmax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a single polarization parameter given as input</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polparam</code></strong> :&ensp;<code><a title="micropolarray.micropol_image.PolParam" href="#micropolarray.micropol_image.PolParam">PolParam</a></code></dt>
<dd>image PolParam containing the parameter to plot. Can be one among [self.I, self.Q, self.U, self.pB, self.AoLP, self.DoLP]</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>colormap for the plot. Defaults to "Greys_r".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>a (figure, axis) couple same as matplotlib.pyplot.subplots</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_pol_param(
    self, polparam: PolParam, cmap=&#34;Greys_r&#34;, vmin=None, vmax=None
):
    &#34;&#34;&#34;Plots a single polarization parameter given as input

    Args:
        polparam (PolParam): image PolParam containing the parameter to plot. Can be one among [self.I, self.Q, self.U, self.pB, self.AoLP, self.DoLP]
        cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

    Returns:
        tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
    &#34;&#34;&#34;
    data_ratio = self.data.shape[0] / self.data.shape[1]
    fig, ax = plt.subplots(dpi=200)
    if vmin is None:
        vmin = mean_minus_std(polparam.data)
    if vmax is None:
        vmax = mean_plus_std(polparam.data)
    mappable = ax.imshow(
        polparam.data,
        cmap=cmap,
        vmin=vmin,
        vmax=vmax,
    )
    ax.set_title(polparam.title)
    ax.set_xlabel(&#34;x [px]&#34;)
    ax.set_ylabel(&#34;y [px]&#34;)
    fig.colorbar(
        mappable,
        ax=ax,
        label=polparam.measure_unit,
        fraction=data_ratio * 0.05,
    )
    return fig, ax</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.show_single_pol_images"><code class="name flex">
<span>def <span class="ident">show_single_pol_images</span></span>(<span>self, cmap='Greys_r')</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the four polarizations images.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>colormap for the plot. Defaults to "Greys_r".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>a (figure, axis) couple same as matplotlib.pyplot.subplots</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_single_pol_images(self, cmap=&#34;Greys_r&#34;):
    &#34;&#34;&#34;Plots the four polarizations images.

    Args:
        cmap (str, optional): colormap for the plot. Defaults to &#34;Greys_r&#34;.

    Returns:
        tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots
    &#34;&#34;&#34;
    data_ratio = self.data.shape[0] / self.data.shape[1]
    fig, ax = plt.subplots(2, 2, figsize=(9, 9), constrained_layout=True)
    ax = ax.ravel()
    polslist = [self.pol0, self.pol45, self.pol90, self.pol_45]
    for i, singlepolax in enumerate(ax):
        mappable = singlepolax.imshow(polslist[i].data, cmap=cmap)
        singlepolax.set_title(polslist[i].title)
        singlepolax.set_xlabel(&#34;x [px]&#34;)
        singlepolax.set_ylabel(&#34;y [px]&#34;)
        fig.colorbar(
            mappable,
            ax=singlepolax,
            label=polslist[i].measure_unit,
            fraction=data_ratio * 0.05,
            pad=0.01,
        )
    return fig, ax</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.show_with_pol_params"><code class="name flex">
<span>def <span class="ident">show_with_pol_params</span></span>(<span>self, cmap='Greys_r') ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a fig for each set of image parameters. User must call
plt.show after this is called.
Returned parameters:
- Original image
- Stokes vector I, Q, U
- Angle, degree of linear polarizaimagetion Polarized brightness</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>colormap string. Defaults to "Greys_r".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>a (figure, axis) couple same as matplotlib.pyplot.subplots for the image data and another for the six polarization parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_with_pol_params(self, cmap=&#34;Greys_r&#34;) -&gt; tuple:
    &#34;&#34;&#34;Returns a fig for each set of image parameters. User must call
    plt.show after this is called.
    Returned parameters:
    - Original image
    - Stokes vector I, Q, U
    - Angle, degree of linear polarizaimagetion Polarized brightness


    Args:
        cmap (str, optional): colormap string. Defaults to &#34;Greys_r&#34;.

    Returns:
        tuple: a (figure, axis) couple same as matplotlib.pyplot.subplots for the image data and another for the six polarization parameters
    &#34;&#34;&#34;
    data_ratio = self.data.shape[0] / self.data.shape[1]
    image_fig, imageax = plt.subplots(dpi=200, constrained_layout=True)
    mappable = imageax.imshow(
        self.data,
        cmap=cmap,
        vmin=mean_minus_std(self.data),
        vmax=mean_plus_std(self.data),
    )
    avg = np.mean(self.data)
    stdev = np.std(self.data)
    imageax.set_title(
        f&#34;Image data (avrg {avg:3.2f}+-{stdev:3.2f})&#34;,
        color=&#34;black&#34;,
    )
    imageax.set_xlabel(&#34;x [px]&#34;)
    imageax.set_ylabel(&#34;y [px]&#34;)
    image_fig.colorbar(
        mappable, ax=imageax, label=&#34;[DN]&#34;, fraction=data_ratio * 0.05
    )
    stokes_fig, stokesax = plt.subplots(
        2, 3, figsize=(14, 9), constrained_layout=True
    )

    stokesax = stokesax.ravel()
    for i, stokes in enumerate(stokesax):
        vmin = mean_minus_std(self.polparam_list[i].data)
        vmax = mean_plus_std(self.polparam_list[i].data)
        avg = np.mean(self.polparam_list[i].data)
        stdev = np.std(self.polparam_list[i].data)
        mappable_stokes = stokes.imshow(
            self.polparam_list[i].data, cmap=cmap, vmin=vmin, vmax=vmax
        )
        stokes.set_title(
            self.polparam_list[i].title
            + f&#34; (avrg {avg:3.2f}+-{stdev:3.2f})&#34;,
            color=&#34;black&#34;,
        )
        stokes.set_xlabel(&#34;x [px]&#34;)
        stokes.set_ylabel(&#34;y [px]&#34;)
        stokes_fig.colorbar(
            mappable_stokes,
            ax=stokes,
            label=self.polparam_list[i].measure_unit,
            fraction=data_ratio * 0.05,
        )
    return image_fig, imageax, stokes_fig, stokesax</code></pre>
</details>
</dd>
<dt id="micropolarray.micropol_image.MicropolImage.subtract_dark"><code class="name flex">
<span>def <span class="ident">subtract_dark</span></span>(<span>self, dark: <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a>) ‑> <a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></span>
</code></dt>
<dd>
<div class="desc"><p>Correctly subtracts the input dark image from the image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dark</code></strong> :&ensp;<code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>dark to subtract</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></dt>
<dd>copy of input image with dark subtracted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtract_dark(self, dark: MicropolImage) -&gt; MicropolImage:
    &#34;&#34;&#34;Correctly subtracts the input dark image from the image

    Args:
        dark (MicropolImage): dark to subtract

    Returns:
        MicropolImage: copy of input image with dark subtracted
    &#34;&#34;&#34;
    self.data = self.data - dark.data
    self.data = np.where(self.data &gt;= 0, self.data, 0)  # Fix data
    self._set_data_and_Stokes()
    self._dark_subtracted = True
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="micropolarray.image.Image" href="image.html#micropolarray.image.Image">Image</a></b></code>:
<ul class="hlist">
<li><code><a title="micropolarray.image.Image.save_as_fits" href="image.html#micropolarray.image.Image.save_as_fits">save_as_fits</a></code></li>
<li><code><a title="micropolarray.image.Image.save_as_raw" href="image.html#micropolarray.image.Image.save_as_raw">save_as_raw</a></code></li>
<li><code><a title="micropolarray.image.Image.show" href="image.html#micropolarray.image.Image.show">show</a></code></li>
<li><code><a title="micropolarray.image.Image.show_histogram" href="image.html#micropolarray.image.Image.show_histogram">show_histogram</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="micropolarray.micropol_image.PolParam"><code class="flex name class">
<span>class <span class="ident">PolParam</span></span>
<span>(</span><span>ID: str, data: np.ndarray, title: str, measure_unit: str, fix_data: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Auxiliary class for polarization parameters.</p>
<h2 id="members">Members</h2>
<p>ID (str): parameter identifier
data (np.array): parameter image as numpy 2D array
title (str): brief title of the parameter, useful for plotting
measure_unit (str): initial measure units of the parameter
fix_data (bool): controls whether data has to be constrained to [0, 4096] interval (not implemented yet)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolParam:
    &#34;&#34;&#34;Auxiliary class for polarization parameters.

    Members:
        ID (str): parameter identifier
        data (np.array): parameter image as numpy 2D array
        title (str): brief title of the parameter, useful for plotting
        measure_unit (str): initial measure units of the parameter
        fix_data (bool): controls whether data has to be constrained to [0, 4096] interval (not implemented yet)
    &#34;&#34;&#34;

    ID: str
    data: np.ndarray
    title: str
    measure_unit: str
    fix_data: bool</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="micropolarray.micropol_image.PolParam.ID"><code class="name">var <span class="ident">ID</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="micropolarray.micropol_image.PolParam.data"><code class="name">var <span class="ident">data</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="micropolarray.micropol_image.PolParam.fix_data"><code class="name">var <span class="ident">fix_data</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="micropolarray.micropol_image.PolParam.measure_unit"><code class="name">var <span class="ident">measure_unit</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="micropolarray.micropol_image.PolParam.title"><code class="name">var <span class="ident">title</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="micropolarray" href="index.html">micropolarray</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="micropolarray.micropol_image.set_default_angles" href="#micropolarray.micropol_image.set_default_angles">set_default_angles</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="micropolarray.micropol_image.MicropolImage" href="#micropolarray.micropol_image.MicropolImage">MicropolImage</a></code></h4>
<ul class="">
<li><code><a title="micropolarray.micropol_image.MicropolImage.clean_hot_pixels" href="#micropolarray.micropol_image.MicropolImage.clean_hot_pixels">clean_hot_pixels</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.congrid" href="#micropolarray.micropol_image.MicropolImage.congrid">congrid</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.correct_flat" href="#micropolarray.micropol_image.MicropolImage.correct_flat">correct_flat</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.correct_ifov" href="#micropolarray.micropol_image.MicropolImage.correct_ifov">correct_ifov</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.demodulate" href="#micropolarray.micropol_image.MicropolImage.demodulate">demodulate</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.demosaic" href="#micropolarray.micropol_image.MicropolImage.demosaic">demosaic</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.first_call" href="#micropolarray.micropol_image.MicropolImage.first_call">first_call</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.mask_occulter" href="#micropolarray.micropol_image.MicropolImage.mask_occulter">mask_occulter</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.rebin" href="#micropolarray.micropol_image.MicropolImage.rebin">rebin</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.rotate" href="#micropolarray.micropol_image.MicropolImage.rotate">rotate</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.save_all_pol_params_as_fits" href="#micropolarray.micropol_image.MicropolImage.save_all_pol_params_as_fits">save_all_pol_params_as_fits</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.save_demosaiced_images_as_fits" href="#micropolarray.micropol_image.MicropolImage.save_demosaiced_images_as_fits">save_demosaiced_images_as_fits</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.save_param_as_fits" href="#micropolarray.micropol_image.MicropolImage.save_param_as_fits">save_param_as_fits</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.save_single_pol_images" href="#micropolarray.micropol_image.MicropolImage.save_single_pol_images">save_single_pol_images</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.set_data_only" href="#micropolarray.micropol_image.MicropolImage.set_data_only">set_data_only</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.shift" href="#micropolarray.micropol_image.MicropolImage.shift">shift</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.show_demo_images" href="#micropolarray.micropol_image.MicropolImage.show_demo_images">show_demo_images</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.show_pol_param" href="#micropolarray.micropol_image.MicropolImage.show_pol_param">show_pol_param</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.show_single_pol_images" href="#micropolarray.micropol_image.MicropolImage.show_single_pol_images">show_single_pol_images</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.show_with_pol_params" href="#micropolarray.micropol_image.MicropolImage.show_with_pol_params">show_with_pol_params</a></code></li>
<li><code><a title="micropolarray.micropol_image.MicropolImage.subtract_dark" href="#micropolarray.micropol_image.MicropolImage.subtract_dark">subtract_dark</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="micropolarray.micropol_image.PolParam" href="#micropolarray.micropol_image.PolParam">PolParam</a></code></h4>
<ul class="">
<li><code><a title="micropolarray.micropol_image.PolParam.ID" href="#micropolarray.micropol_image.PolParam.ID">ID</a></code></li>
<li><code><a title="micropolarray.micropol_image.PolParam.data" href="#micropolarray.micropol_image.PolParam.data">data</a></code></li>
<li><code><a title="micropolarray.micropol_image.PolParam.fix_data" href="#micropolarray.micropol_image.PolParam.fix_data">fix_data</a></code></li>
<li><code><a title="micropolarray.micropol_image.PolParam.measure_unit" href="#micropolarray.micropol_image.PolParam.measure_unit">measure_unit</a></code></li>
<li><code><a title="micropolarray.micropol_image.PolParam.title" href="#micropolarray.micropol_image.PolParam.title">title</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>