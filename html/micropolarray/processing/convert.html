<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>micropolarray.processing.convert API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>micropolarray.processing.convert</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import numpy as np
import multiprocessing as mp
from astropy.io import fits
import sys
import tqdm
import datetime
import pytz
from logging import critical, info
from pathlib import Path


def three_bytes_to_two_ints(filecontent):
    &#34;&#34;&#34;Needed for parallelization, this will be run by each thread for a slice of the original array.

    Returns:
        np.array: array of saved data
    &#34;&#34;&#34;
    newarr = np.zeros(shape=int(len(filecontent) * 2 / 3))
    position = 0
    for i in range(0, len(filecontent), 3):
        binsum = &#34;&#34;.join([bin(j)[2:].zfill(8) for j in filecontent[i : i + 3]])
        newarr[position] = int(binsum[0:12], 2)
        newarr[position + 1] = int(binsum[16:24] + binsum[12:16], 2)
        position += 2
    return newarr


def nparr_from_binary(filename):
    &#34;&#34;&#34;Converts a PolarCam binary file into a numpy array. Bytes are saved like this

     - 24 bit (3 bytes)
         1             |   3                |     2
    111111111111       | 1111               | 11111111
     - 2 numbers
    First number 12bit | Second number (little endian) 8+4=12 bit

    Args:
        filename (str): name of the file to be converted

    Raises:
        ValueError: file lenghts is indivisible by the number of chunks requested to parallelize operations

    Returns:
        np.array: array of data from file
    &#34;&#34;&#34;
    with open(filename, mode=&#34;rb&#34;) as file:
        filecontent = file.read()  #  serial representation
    image_dimension = 1952
    newarr = np.zeros(shape=image_dimension * image_dimension)
    chunks_n = 32
    chunk_size = len(filecontent) / chunks_n
    if chunk_size % 1 or (chunk_size / 3) % 1:
        raise ValueError(&#34;Indivisible by chunks&#34;)
    chunk_size = int(chunk_size)
    splitted = np.array(
        [
            filecontent[i * chunk_size : (i + 1) * chunk_size]
            for i in range(chunks_n)
        ]
    )
    with mp.Pool(processes=chunks_n) as p:
        result = p.map(three_bytes_to_two_ints, splitted)
    newarr = np.array(result).reshape((1952, 1952))
    return newarr


def convert_set(filenames, new_filename, height, width):
    &#34;&#34;&#34;ANTARTICOR ONLY: Sums a set of filenames and converts them to one fits file.


    Args:
        filenames (list): list of file names to be summed before being converted
        new_filename (str): new .fits file name
    &#34;&#34;&#34;
    abs_new_filename = os.path.abspath(new_filename)
    if abs_new_filename.split(&#34;.&#34;)[-1] != &#34;fits&#34;:
        raise ValueError(
            &#34;Trying to save a .fits file to .bin, check new filename&#34;
        )
    if type(filenames) is not list:
        filenames = [
            filenames,
        ]
    images_n = len(filenames)
    arr = np.zeros(shape=(height, width))
    for filename in tqdm.tqdm(filenames):
        arr += nparr_from_binary(filename) / images_n
    hdu = fits.PrimaryHDU(data=arr)
    date_and_time = datetime.datetime.now(
        tz=pytz.timezone(&#34;Australia/Perth&#34;)
    ).strftime(&#34;%Y-%m-%dT%H:%M:%S%z&#34;)
    hdu.header[&#34;CREATED&#34;] = (
        str(date_and_time),
        &#34;Datetime conversion from bin to fits file (Dome C timezone).&#34;,
    )
    hdu.writeto(abs_new_filename, overwrite=True)


def average_rawfiles_to_fits(
    filenames: list, new_filename: str, height: int, width: int
):
    &#34;&#34;&#34;Saves the mean of a list of rawfiles to a new fits file.

    Args:
        filenames (list): list of raw filenames
        new_filename (str): new fits filename
        height (int): image height in pix
        width (int): image width in pix

    Raises:
        ValueError: trying to save in a file that does not end with .fits
    &#34;&#34;&#34;
    abs_new_filename = str(Path(new_filename).absolute())
    if abs_new_filename.split(&#34;.&#34;)[-1] != &#34;fits&#34;:
        raise ValueError(&#34;Output filename must have a .fits extension.&#34;)
    if type(filenames) is not list:
        filenames = [
            filenames,
        ]
    images_n = len(filenames)
    arr = np.zeros(shape=(height, width))
    for filename in tqdm.tqdm(filenames):
        with open(filename, mode=&#34;rb&#34;) as file:
            buffer = file.read()
        data = np.ndarray(shape=(height, width), dtype=&#34;&lt;u2&#34;, buffer=buffer)

        arr += data / images_n
    hdu = fits.PrimaryHDU(data=arr)
    date_and_time = datetime.datetime.now().strftime(&#34;%Y-%m-%dT%H:%M:%S%z&#34;)
    hdu.header[&#34;CREATED&#34;] = (
        str(date_and_time),
        &#34;Datetime conversion from bin to fits file (Dome C timezone).&#34;,
    )
    hdu.writeto(abs_new_filename, overwrite=True)


def convert_rawfile_to_fits(
    filename: str, height: int, width: int, remove_old: bool = False
):
    &#34;&#34;&#34;Converts a raw file to a fits one, using default header

    Args:
        filename (str): raw filename
        height (int): file height
        width (int): file width
        remove_old (bool, optional): remove old raw file after conversion. Defaults to False.

    Raises:
        ValueError: raised if the file does not end with &#34;.raw&#34;
    &#34;&#34;&#34;
    if not &#34;.raw&#34; in filename:
        raise ValueError(&#34;Can&#39;t convert: not a row file&#34;)
    with open(filename, mode=&#34;rb&#34;) as file:
        buffer = file.read()
    data = np.ndarray(shape=(height, width), dtype=&#34;&lt;u2&#34;, buffer=buffer)
    HDU = fits.PrimaryHDU(data=data)
    filename = os.path.abspath(
        filename
    )  # prevents bug when &#34;../&#34; is in filename
    new_filename = os.path.pathsep.join(filename.split(&#34;.&#34;)[:-1]) + &#34;.fits&#34;
    HDU.writeto(new_filename, overwrite=True)
    info(f&#39;Image successfully saved to &#34;{new_filename}&#34;.&#39;)

    if remove_old:
        os.remove(filename)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="micropolarray.processing.convert.average_rawfiles_to_fits"><code class="name flex">
<span>def <span class="ident">average_rawfiles_to_fits</span></span>(<span>filenames: list, new_filename: str, height: int, width: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the mean of a list of rawfiles to a new fits file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code></dt>
<dd>list of raw filenames</dd>
<dt><strong><code>new_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>new fits filename</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>image height in pix</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>image width in pix</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>trying to save in a file that does not end with .fits</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average_rawfiles_to_fits(
    filenames: list, new_filename: str, height: int, width: int
):
    &#34;&#34;&#34;Saves the mean of a list of rawfiles to a new fits file.

    Args:
        filenames (list): list of raw filenames
        new_filename (str): new fits filename
        height (int): image height in pix
        width (int): image width in pix

    Raises:
        ValueError: trying to save in a file that does not end with .fits
    &#34;&#34;&#34;
    abs_new_filename = str(Path(new_filename).absolute())
    if abs_new_filename.split(&#34;.&#34;)[-1] != &#34;fits&#34;:
        raise ValueError(&#34;Output filename must have a .fits extension.&#34;)
    if type(filenames) is not list:
        filenames = [
            filenames,
        ]
    images_n = len(filenames)
    arr = np.zeros(shape=(height, width))
    for filename in tqdm.tqdm(filenames):
        with open(filename, mode=&#34;rb&#34;) as file:
            buffer = file.read()
        data = np.ndarray(shape=(height, width), dtype=&#34;&lt;u2&#34;, buffer=buffer)

        arr += data / images_n
    hdu = fits.PrimaryHDU(data=arr)
    date_and_time = datetime.datetime.now().strftime(&#34;%Y-%m-%dT%H:%M:%S%z&#34;)
    hdu.header[&#34;CREATED&#34;] = (
        str(date_and_time),
        &#34;Datetime conversion from bin to fits file (Dome C timezone).&#34;,
    )
    hdu.writeto(abs_new_filename, overwrite=True)</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.convert.convert_rawfile_to_fits"><code class="name flex">
<span>def <span class="ident">convert_rawfile_to_fits</span></span>(<span>filename: str, height: int, width: int, remove_old: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a raw file to a fits one, using default header</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>raw filename</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>file height</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>file width</dd>
<dt><strong><code>remove_old</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>remove old raw file after conversion. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>raised if the file does not end with ".raw"</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_rawfile_to_fits(
    filename: str, height: int, width: int, remove_old: bool = False
):
    &#34;&#34;&#34;Converts a raw file to a fits one, using default header

    Args:
        filename (str): raw filename
        height (int): file height
        width (int): file width
        remove_old (bool, optional): remove old raw file after conversion. Defaults to False.

    Raises:
        ValueError: raised if the file does not end with &#34;.raw&#34;
    &#34;&#34;&#34;
    if not &#34;.raw&#34; in filename:
        raise ValueError(&#34;Can&#39;t convert: not a row file&#34;)
    with open(filename, mode=&#34;rb&#34;) as file:
        buffer = file.read()
    data = np.ndarray(shape=(height, width), dtype=&#34;&lt;u2&#34;, buffer=buffer)
    HDU = fits.PrimaryHDU(data=data)
    filename = os.path.abspath(
        filename
    )  # prevents bug when &#34;../&#34; is in filename
    new_filename = os.path.pathsep.join(filename.split(&#34;.&#34;)[:-1]) + &#34;.fits&#34;
    HDU.writeto(new_filename, overwrite=True)
    info(f&#39;Image successfully saved to &#34;{new_filename}&#34;.&#39;)

    if remove_old:
        os.remove(filename)</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.convert.convert_set"><code class="name flex">
<span>def <span class="ident">convert_set</span></span>(<span>filenames, new_filename, height, width)</span>
</code></dt>
<dd>
<div class="desc"><p>ANTARTICOR ONLY: Sums a set of filenames and converts them to one fits file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code></dt>
<dd>list of file names to be summed before being converted</dd>
<dt><strong><code>new_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>new .fits file name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_set(filenames, new_filename, height, width):
    &#34;&#34;&#34;ANTARTICOR ONLY: Sums a set of filenames and converts them to one fits file.


    Args:
        filenames (list): list of file names to be summed before being converted
        new_filename (str): new .fits file name
    &#34;&#34;&#34;
    abs_new_filename = os.path.abspath(new_filename)
    if abs_new_filename.split(&#34;.&#34;)[-1] != &#34;fits&#34;:
        raise ValueError(
            &#34;Trying to save a .fits file to .bin, check new filename&#34;
        )
    if type(filenames) is not list:
        filenames = [
            filenames,
        ]
    images_n = len(filenames)
    arr = np.zeros(shape=(height, width))
    for filename in tqdm.tqdm(filenames):
        arr += nparr_from_binary(filename) / images_n
    hdu = fits.PrimaryHDU(data=arr)
    date_and_time = datetime.datetime.now(
        tz=pytz.timezone(&#34;Australia/Perth&#34;)
    ).strftime(&#34;%Y-%m-%dT%H:%M:%S%z&#34;)
    hdu.header[&#34;CREATED&#34;] = (
        str(date_and_time),
        &#34;Datetime conversion from bin to fits file (Dome C timezone).&#34;,
    )
    hdu.writeto(abs_new_filename, overwrite=True)</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.convert.nparr_from_binary"><code class="name flex">
<span>def <span class="ident">nparr_from_binary</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a PolarCam binary file into a numpy array. Bytes are saved like this</p>
<ul>
<li>24 bit (3 bytes)
1
|
3
|
2
111111111111
| 1111
| 11111111</li>
<li>2 numbers
First number 12bit | Second number (little endian) 8+4=12 bit</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the file to be converted</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>file lenghts is indivisible by the number of chunks requested to parallelize operations</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>array of data from file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nparr_from_binary(filename):
    &#34;&#34;&#34;Converts a PolarCam binary file into a numpy array. Bytes are saved like this

     - 24 bit (3 bytes)
         1             |   3                |     2
    111111111111       | 1111               | 11111111
     - 2 numbers
    First number 12bit | Second number (little endian) 8+4=12 bit

    Args:
        filename (str): name of the file to be converted

    Raises:
        ValueError: file lenghts is indivisible by the number of chunks requested to parallelize operations

    Returns:
        np.array: array of data from file
    &#34;&#34;&#34;
    with open(filename, mode=&#34;rb&#34;) as file:
        filecontent = file.read()  #  serial representation
    image_dimension = 1952
    newarr = np.zeros(shape=image_dimension * image_dimension)
    chunks_n = 32
    chunk_size = len(filecontent) / chunks_n
    if chunk_size % 1 or (chunk_size / 3) % 1:
        raise ValueError(&#34;Indivisible by chunks&#34;)
    chunk_size = int(chunk_size)
    splitted = np.array(
        [
            filecontent[i * chunk_size : (i + 1) * chunk_size]
            for i in range(chunks_n)
        ]
    )
    with mp.Pool(processes=chunks_n) as p:
        result = p.map(three_bytes_to_two_ints, splitted)
    newarr = np.array(result).reshape((1952, 1952))
    return newarr</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.convert.three_bytes_to_two_ints"><code class="name flex">
<span>def <span class="ident">three_bytes_to_two_ints</span></span>(<span>filecontent)</span>
</code></dt>
<dd>
<div class="desc"><p>Needed for parallelization, this will be run by each thread for a slice of the original array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>array of saved data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def three_bytes_to_two_ints(filecontent):
    &#34;&#34;&#34;Needed for parallelization, this will be run by each thread for a slice of the original array.

    Returns:
        np.array: array of saved data
    &#34;&#34;&#34;
    newarr = np.zeros(shape=int(len(filecontent) * 2 / 3))
    position = 0
    for i in range(0, len(filecontent), 3):
        binsum = &#34;&#34;.join([bin(j)[2:].zfill(8) for j in filecontent[i : i + 3]])
        newarr[position] = int(binsum[0:12], 2)
        newarr[position + 1] = int(binsum[16:24] + binsum[12:16], 2)
        position += 2
    return newarr</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="micropolarray.processing" href="index.html">micropolarray.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="micropolarray.processing.convert.average_rawfiles_to_fits" href="#micropolarray.processing.convert.average_rawfiles_to_fits">average_rawfiles_to_fits</a></code></li>
<li><code><a title="micropolarray.processing.convert.convert_rawfile_to_fits" href="#micropolarray.processing.convert.convert_rawfile_to_fits">convert_rawfile_to_fits</a></code></li>
<li><code><a title="micropolarray.processing.convert.convert_set" href="#micropolarray.processing.convert.convert_set">convert_set</a></code></li>
<li><code><a title="micropolarray.processing.convert.nparr_from_binary" href="#micropolarray.processing.convert.nparr_from_binary">nparr_from_binary</a></code></li>
<li><code><a title="micropolarray.processing.convert.three_bytes_to_two_ints" href="#micropolarray.processing.convert.three_bytes_to_two_ints">three_bytes_to_two_ints</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>