<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>micropolarray.processing.demodulation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>micropolarray.processing.demodulation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import glob
import multiprocessing as mp
import os
import re
import sys
import time
from logging import error, info, warning

import matplotlib.pyplot as plt
import numpy as np
from astropy.io import fits
from scipy.optimize import curve_fit
from tqdm import tqdm

from micropolarray.cameras import PolarCam
from micropolarray.processing.chen_wan_liang_calibration import ifov_jitcorrect
from micropolarray.processing.nrgf import (
    find_occulter_position,
    roi_from_polar,
)
from micropolarray.processing.rebin import (
    micropolarray_rebin,
    standard_rebin,
    trim_to_match_binning,
)
from micropolarray.utils import mean_plus_std

# Shape of the demodulation matrix
N_PIXELS_IN_SUPERPIX = 4
N_MALUS_PARAMS = 3


class Demodulator:
    &#34;&#34;&#34;Demodulation class needed for MicropolImage
    demodulation.&#34;&#34;&#34;

    def __init__(self, demo_matrices_path: str):
        self.n_pixels_in_superpix = N_PIXELS_IN_SUPERPIX
        self.n_malus_params = N_MALUS_PARAMS
        self.demo_matrices_path = demo_matrices_path

        self.mij = self._get_demodulation_tensor()

    def _get_demodulation_tensor(self):
        &#34;&#34;&#34;Reads files &#34;MIJ.fits&#34; from path folder and returns a (3,4,y,x)
        numpy array representing the demodulation tensor.

        Args:
            binning (bool, optional): _description_. Defaults to False.

        Raises:
            FileNotFoundError: couldn&#39;t find the matrices in the specified path

        Returns:
            ndarray: (3, 4, *data.shape) array containing the demodulation tensor
        &#34;&#34;&#34;

        if not os.path.exists(self.demo_matrices_path):
            raise FileNotFoundError(&#34;self.demo_matrices_path not found.&#34;)
        filenames_list = glob.glob(
            self.demo_matrices_path + os.path.sep + &#34;*.fits&#34;
        )

        with fits.open(filenames_list[0]) as firsthul:
            sample_data = np.array(firsthul[0].data)
        Mij = np.zeros(
            shape=(
                self.n_malus_params,
                self.n_pixels_in_superpix,
                sample_data.shape[0],
                sample_data.shape[1],
            ),
            dtype=float,
        )

        matches = 0
        for filename in filenames_list:
            if (
                re.search(&#34;[Mm][0-9]{2}&#34;, filename.split(os.path.sep)[-1])
                is not None
            ):  # Exclude files not matching m/Mij
                matches += 1
                i, j = re.search(
                    &#34;[Mm][0-9]{2}&#34;, filename.split(os.path.sep)[-1]
                ).group()[
                    -2:
                ]  # Searches for pattern M/m + ij as last string before .fits
                i = int(i)
                j = int(j)
                with fits.open(filename) as hul:
                    Mij[i, j] = hul[0].data
        if matches != 12:
            raise ValueError(
                &#34;Some matrices were not found in the selected folder. Check correct folder name and files pattern Mij.fits or mij.fits&#34;
            )

        return Mij

    def show(self, vmin=-1, vmax=1, cmap=&#34;Greys&#34;) -&gt; tuple:
        &#34;&#34;&#34;Shows the demodulation tensor

        Args:
            vmin (int, optional): Minimum shown value. Defaults to -1.
            vmax (int, optional): Maximum shown value. Defaults to 1.
            cmap (str, optional): Colormap of the plot. Defaults to &#34;Greys&#34;.

        Returns:
            tuple: fig, ax tuple as returned by matplotlib.pyplot.subplots
        &#34;&#34;&#34;
        fig, ax = plt.subplots(
            3,
            4,
            dpi=300,
            figsize=(4, 3),
            constrained_layout=True,
            sharex=&#34;col&#34;,
            sharey=&#34;row&#34;,
        )
        for i in range(3):
            for j in range(4):
                mappable = ax[i, j].imshow(
                    self.mij[i, j], cmap=cmap, vmin=vmin, vmax=vmax
                )
                ax[i, j].set_title(rf&#34;M$_{i}$$_{j}$&#34;)
        for ax in fig.get_axes():
            ax.label_outer()

        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(mappable, cax=cbar_ax)

        return fig, ax

    def rebin(self, binning):  # TODO
        &#34;&#34;&#34;DO NOT USE THIS, calculate the tensor from the binned images&#34;&#34;&#34;
        if (int(self.mij.shape[2] / binning) % 2) or (
            int(self.mij.shape[3] / binning) % 2
        ):
            raise ValueError(
                f&#34;incorrect binning, resulting matrix would be {int(self.mij.shape[2] / binning)}x{int(self.mij.shape[3] / binning)} (not even values).&#34;
            )
        new_demodulator = Demodulator(self.demo_matrices_path)
        new_mij = np.zeros(
            shape=(
                new_demodulator.n_malus_params,
                new_demodulator.n_pixels_in_superpix,
                int(new_demodulator.mij.shape[2] / binning),
                int(new_demodulator.mij.shape[3] / binning),
            )
        )
        for j in range(new_demodulator.n_malus_params):
            for i in range(new_demodulator.n_pixels_in_superpix):
                new_mij[j, i] = standard_rebin(
                    new_demodulator.mij[j, i], binning
                ) / (binning * binning)
        new_demodulator.mij = new_mij

        return new_demodulator

    def rot90(self, k=1):
        # NB: rotation could switch micropol positions inside superpixel, but for demo matrix all px in superpix are equal
        for i in range(self.n_malus_params):
            for j in range(self.n_pixels_in_superpix):
                self.mij[i, j] = np.rot90(self.mij[i, j], k=k)

    def flip(self, axis):
        for i in range(self.n_malus_params):
            for j in range(self.n_pixels_in_superpix):
                self.mij[i, j] = np.flip(self.mij[i, j], axis=axis)


def calculate_demodulation_tensor(
    polarizer_orientations,
    filenames_list,
    micropol_phases_previsions,
    gain,  #  needed for errors
    output_dir,
    binning=1,
    occulter=None,
    procs_grid=[4, 4],
    dark_filename=None,
    flat_filename=None,
    normalizing_S=None,
    DEBUG=False,
):
    &#34;&#34;&#34;Calculates the demodulation tensor images and saves them. Requires a set of images with different polarizations to fit a Malus curve model.

    Args:
        polarizer_orientations (list[float]): List containing the orientations of the incoming light for each image.
        filenames_list (list[str]): List of input images filenames to read. Must include [0, 45, 90, -45].
        micropol_phases_previsions (list[float]): Previsions for the micropolarizer orientations required to initialize fit.
        gain (float): Detector [e-/DN], required to compute errors.
        output_dir (str): output folder to save matrix to.
        binning (int, optional): Output matrices binning. Defaults to 1 (no binning). Be warned that binning matrices AFTER calculation is an incorrect operation.
        occulter (list, optional): occulter y, x center and radius to exclude from calculations. Defaults to None.
        procs_grid ([int, int], optional): number of processors per side [Y, X], parallelization will be done in a Y x X grid. Defaults to [4,4] (16 procs in a 4x4 grid).
        dark_filename (str, optional): Dark image filename to correct input images. Defaults to None.
        flat_filename (str, optional): Flat image filename to correct input images. Defaults to None.
        normalizing_S (float, optional): maximum signal used to normalize single pixel signal. Defaults to None.

    Raises:
        ValueError: Raised if any among [0, 45, 90, -45] is not included in the input polarizations.

    Notes:
        In the binning process the sum of values is considered, which is ok because data is normalized over the maximum S before being fitted.
    &#34;&#34;&#34;

    correct_ifov = True

    # polarizations = array of polarizer orientations
    # filenames_list = list of filenames
    firstcall = True
    if (normalizing_S is None) and (
        not np.all(np.isin([0, 45, 90, -45], polarizer_orientations))
    ):
        raise ValueError(
            &#34;Each one among (0, 45, 90, -45) polarizations must be included in the polarizer orientation array&#34;
        )  # for calculating normalizing_S
    # Have to be sorted
    polarizer_orientations, filenames_list = (
        list(t)
        for t in zip(*sorted(zip(polarizer_orientations, filenames_list)))
    )
    micropol_phases_previsions = np.array(micropol_phases_previsions)
    rad_micropol_phases_previsions = np.deg2rad(micropol_phases_previsions)

    # Flag occulter position to not be fitted, expand to superpixel.
    with fits.open(filenames_list[0]) as file:
        data = file[0].data  # get data dimension

    print(&#34;qui&#34;)
    # Count binning before dimensions
    data = np.array(data, dtype=float)
    data = micropolarray_rebin(data, *data.shape, binning=binning)
    height, width = data.shape

    occulter_flag = np.ones_like(data)  # 0 if not a occulted px, 1 otherwise
    if occulter:
        # info(&#34;Cleaning occulter...&#34;)
        ## Mean values from coronal observations 2022_12_03
        ## (campagna_2022/mean_occulter_pos.py)
        # occulter_y, occulter_x, occulter_r = PolarCam().occulter_pos_last
        # overoccult = 16
        # overoccult = 0
        # occulter_r = occulter_r + overoccult

        # Match binning if needed
        binned_occulter = [int(val / binning) for val in occulter]
        occulter_y, occulter_x, occulter_r = binned_occulter

        occulter_flag = roi_from_polar(
            occulter_flag, [occulter_y, occulter_x], [0, occulter_r]
        )
        for super_y in range(0, occulter_flag.shape[0], 2):
            for super_x in range(0, occulter_flag.shape[1], 2):
                if np.any(
                    occulter_flag[super_y : super_y + 2, super_x : super_x + 2]
                ):
                    occulter_flag[
                        super_y : super_y + 2, super_x : super_x + 2
                    ] = 1
                    continue
    else:
        occulter_flag *= 0

    # Collect dark
    if dark_filename:
        with fits.open(dark_filename) as file:
            dark = np.array(file[0].data, dtype=np.float)
            dark = micropolarray_rebin(dark, *dark.shape, binning)
    # Collect flat field, normalize it
    if flat_filename:
        with fits.open(flat_filename) as file:
            flat = np.array(file[0].data, dtype=np.float)
        if correct_ifov:
            flat = ifov_jitcorrect(flat, *flat.shape)
        flat = micropolarray_rebin(flat, *flat.shape, binning)
        # flat_max = np.max(flat, axis=(0, 1))
        flat_max = mean_plus_std(flat, stds_n=1)
    if flat_filename and dark_filename:
        flat -= dark  # correct flat too
        flat = np.where(flat &gt; 0, flat, 1.0)
        if occulter:
            flat = np.where(occulter_flag, 1.0, flat)
        # flat_max = np.max(flat, axis=(0, 1))
        flat_max = mean_plus_std(flat, stds_n=1)
    if flat_filename:
        normalized_flat = np.where(occulter_flag, 1.0, flat / flat_max)

    # collect data
    all_data_arr = [0.0] * len(filenames_list)
    info(&#34;Collecting data from files...&#34;)
    for idx, filename in enumerate(filenames_list):
        with fits.open(filename) as file:
            all_data_arr[idx] = np.array(file[0].data, dtype=float)
            if correct_ifov:
                all_data_arr[idx] = ifov_jitcorrect(
                    all_data_arr[idx], *all_data_arr[idx].shape
                )
            all_data_arr[idx] = micropolarray_rebin(
                all_data_arr[idx], *all_data_arr[idx].shape, binning
            )
            if dark_filename is not None:
                all_data_arr[idx] -= dark
                all_data_arr[idx] = np.where(
                    all_data_arr[idx] &gt;= 0, all_data_arr[idx], 0.0
                )
            if flat_filename is not None:
                all_data_arr[idx] = np.divide(
                    all_data_arr[idx],
                    normalized_flat,
                    where=normalized_flat != 0.0,
                )
    all_data_arr = np.array(all_data_arr)

    if DEBUG:
        procs_grid = [1, 1]

    # parallelize into a procs_per_size x procs_per_size grid
    info(&#34;Splitting into subdomains to parallelize...&#34;)
    chunks_n_y, chunks_n_x = procs_grid
    chunk_size_y = int(height / chunks_n_y)
    chunk_size_x = int(width / chunks_n_x)
    if (chunk_size_x % 2) or (chunk_size_y % 2):
        raise ValueError(
            f&#34;cant decompose into a {procs_grid[0]}x{procs_grid[1]} grid (odd side grid {chunk_size_y}x{chunk_size_x}). Try changing the number of processors.&#34;
        )
    splitted_data = np.zeros(
        shape=(
            chunks_n_y * chunks_n_x,
            len(polarizer_orientations),
            chunk_size_y,
            chunk_size_x,
        )
    )
    splitted_occulter = np.zeros(
        shape=(chunks_n_y * chunks_n_x, chunk_size_y, chunk_size_x)
    )
    for i in range(chunks_n_y):
        for j in range(chunks_n_x):
            splitted_data[i + chunks_n_y * j] = np.array(
                all_data_arr[
                    :,
                    i * (chunk_size_y) : (i + 1) * chunk_size_y,
                    j * (chunk_size_x) : (j + 1) * chunk_size_x,
                ]
            )  # shape = (chunks_n*chunks_n, len(filenames_list), chunk_size_y, chunk_size_x)
            splitted_occulter[i + chunks_n_y * j] = np.array(
                occulter_flag[
                    i * (chunk_size_y) : (i + 1) * chunk_size_y,
                    j * (chunk_size_x) : (j + 1) * chunk_size_x,
                ]
            )  # shape = (chunks_n*chunks_n, chunk_size_y, chunk_size_x)

    if normalizing_S is None:
        info(&#34;Calculating normalization...&#34;)
        S_max = np.zeros(
            shape=(height, width)
        )  # tk_sum = tk_0 + tk_45 + tk_90 + tk_45
        for pol, image in zip(polarizer_orientations, all_data_arr):
            if pol in [0, 90, 45, -45]:
                S_max += 0.5 * image
        # Normalizing S, has a spike of which maximum is taken
        bins = 1000
        histo = np.histogram(S_max, bins=bins)
        maxvalue = np.max(histo[0])
        index = np.where(histo[0] == maxvalue)[0][0]
        normalizing_S = (
            histo[1][index] + histo[1][index + 1] + histo[1][index - 1]
        ) / 3
        # normalizing_S = np.max(S_max) # old

        # ----------------------------------------------
        # fit gaussian to S for normalization signal
        def gauss(x, norm, x_0, sigma):
            return norm * np.exp(-((x - x_0) ** 2) / (4 * sigma**2))

        hist_roi = 10  # bins around max value
        xvalues = np.array(histo[1])[index - hist_roi : index + hist_roi]
        yvalues = np.array(histo[0])[index - hist_roi : index + hist_roi]
        yvalues_sum = np.sum(yvalues)
        yvalues = yvalues / yvalues_sum
        xvalues = np.array(
            [value + (xvalues[1] - xvalues[0]) / 2 for value in xvalues]
        )  # shift each bin to center
        prediction = [
            yvalues[int(len(yvalues) / 2)],  # normalization
            xvalues[int(len(xvalues) / 2)],  # center
            xvalues[int(len(xvalues) / 2) + int(hist_roi / 2)]
            - xvalues[int(len(xvalues) / 2)],  # sigma
        ]
        params, cov = curve_fit(
            gauss,
            xvalues,
            yvalues,
            prediction,
        )
        normalizing_S = (
            params[1] + 4 * params[2]
        )  # center of gaussian + 2sigma
        # 3sigma -&gt; P = 2.7e-3 outliers
        # 4sigma -&gt; P = 6.3e-5 outliers
        # ----------------------------------------------
    else:
        normalizing_S *= binning * binning  # account binning

    # Debug
    if False:
        index = 0
        histo_0 = np.histogram(all_data_arr[index], bins=1000)
        fig, ax = plt.subplots(figsize=(9, 9))
        ax.stairs(histo_0[0], histo_0[1], label=&#34;sample image&#34;)
        ax.stairs(histo[0], histo[1], label=f&#34;S, max = {np.max(S_max)}&#34;)
        ax.axvline(normalizing_S, color=&#34;red&#34;, label=&#34;normalizing_S&#34;)
        # ax.plot(
        #    xvalues,
        #    gauss(xvalues, params[0] * yvalues_sum, params[1], params[2]),
        #    label=&#34;Fitted curve for normalizing S&#34;,
        # )
        ax.set_title(f&#34;Prepol at {polarizer_orientations[index]} deg&#34;)
        ax.set_xlabel(&#34;S [DN]&#34;)
        ax.set_ylabel(&#34;Counts&#34;)
        ax.legend()
        plt.show()
        sys.exit()

    args = (
        [
            splitted_data[i],
            normalizing_S,
            splitted_occulter[i],
            polarizer_orientations,
            rad_micropol_phases_previsions,
            gain,
            DEBUG,
        ]
        for i in range(chunks_n_y * chunks_n_x)
    )

    starting_time = time.perf_counter()
    loc_time = time.strftime(&#34;%H:%M:%S  (%Y/%m/%d)&#34;, time.localtime())
    info(
        f&#34;Starting parallel calculation ({procs_grid[0]}x{procs_grid[1]}) processors&#34;
    )

    if procs_grid != [1, 1]:
        try:
            with mp.Pool(processes=chunks_n_y * chunks_n_x) as p:
                result = p.starmap(
                    compute_demodulation_by_chunk,
                    args,
                )
        except:
            error(&#34;Fit not found&#34;)
            ending_time = time.perf_counter()

            info(f&#34;Elapsed : {(ending_time - starting_time)/60:3.2f} mins&#34;)
            sys.exit()

    else:
        arglist = [arg for arg in args]
        result = [[0.0, 0.0]] * chunks_n_y * chunks_n_x

        for i in range(chunks_n_y * chunks_n_x):
            result[i] = compute_demodulation_by_chunk(*arglist[i])

    loc_time = time.strftime(&#34;%H:%M:%S (%Y/%m/%d)&#34;, time.localtime())
    info(f&#34;Ending parallel calculation&#34;)

    ending_time = time.perf_counter()
    info(f&#34;Elapsed : {(ending_time - starting_time)/60:3.2f} mins&#34;)

    result = np.array(result)
    m_ij = np.zeros(
        shape=(N_MALUS_PARAMS, N_PIXELS_IN_SUPERPIX, height, width)
    )
    tks = np.zeros(shape=(height, width))
    efficiences = np.zeros(shape=(height, width))
    phases = np.zeros(shape=(height, width))

    for i in range(chunks_n_y):
        for j in range(chunks_n_x):
            m_ij[
                :,
                :,
                i * (chunk_size_y) : (i + 1) * chunk_size_y,
                j * (chunk_size_x) : (j + 1) * chunk_size_x,
            ] = result[i + chunks_n_y * j, 0].reshape(
                N_MALUS_PARAMS,
                N_PIXELS_IN_SUPERPIX,
                chunk_size_y,
                chunk_size_x,
            )
            tks[
                i * (chunk_size_y) : (i + 1) * chunk_size_y,
                j * (chunk_size_x) : (j + 1) * chunk_size_x,
            ] = result[i + chunks_n_y * j, 1].reshape(
                chunk_size_y, chunk_size_x
            )
            efficiences[
                i * (chunk_size_y) : (i + 1) * chunk_size_y,
                j * (chunk_size_x) : (j + 1) * chunk_size_x,
            ] = result[i + chunks_n_y * j, 2].reshape(
                chunk_size_y, chunk_size_x
            )
            phases[
                i * (chunk_size_y) : (i + 1) * chunk_size_y,
                j * (chunk_size_x) : (j + 1) * chunk_size_x,
            ] = result[i + chunks_n_y * j, 3].reshape(
                chunk_size_y, chunk_size_x
            )

    phases = np.rad2deg(phases)

    if DEBUG:
        # prevents overwriting
        sys.exit()

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    for i in range(N_MALUS_PARAMS):
        for j in range(N_PIXELS_IN_SUPERPIX):
            hdu = fits.PrimaryHDU(data=m_ij[i, j])
            hdu.writeto(output_dir + f&#34;M{i}{j}.fits&#34;, overwrite=True)
    hdu = fits.PrimaryHDU(data=tks)
    hdu.writeto(output_dir + &#34;transmittancies.fits&#34;, overwrite=True)
    hdu = fits.PrimaryHDU(data=efficiences)
    hdu.writeto(output_dir + &#34;efficiences.fits&#34;, overwrite=True)
    hdu = fits.PrimaryHDU(data=phases)
    hdu.writeto(output_dir + &#34;phases.fits&#34;, overwrite=True)

    info(&#34;Demodulation matrices and fit data successfully saved!&#34;)

    return


def compute_demodulation_by_chunk(
    splitted_dara_arr,
    normalizing_S,
    splitted_occulter_flag,
    polarizer_orientations,
    rad_micropol_phases_previsions,
    gain,
    DEBUG,
):
    &#34;&#34;&#34;Utility function to parallelize calculations.&#34;&#34;&#34;
    N_MALUS_PARAMS = 3
    N_PIXELS_IN_SUPERPIX = 4
    # Preemptly compute the theoretical demo matrix to save time
    theo_modulation_matrix = np.array(
        [
            [0.5, 0.5, 0.5, 0.5],
            [
                0.5 * np.cos(2.0 * rad_micropol_phases_previsions[i])
                for i in range(N_PIXELS_IN_SUPERPIX)
            ],
            [
                0.5 * np.sin(2.0 * rad_micropol_phases_previsions[i])
                for i in range(N_PIXELS_IN_SUPERPIX)
            ],
        ]
    )
    theo_modulation_matrix = theo_modulation_matrix.T
    theo_demodulation_matrix = np.linalg.pinv(theo_modulation_matrix)

    num_of_points, height, width = splitted_dara_arr.shape
    rad_micropol_phases_previsions = np.array(rad_micropol_phases_previsions)
    polarizations_rad = np.deg2rad(polarizer_orientations)
    tk_prediction = 0.5
    efficiency_prediction = 0.4

    # Checked errors
    sigma_S2 = np.sqrt(0.5 * normalizing_S / gain)
    normalizing_S2 = normalizing_S * normalizing_S
    # pix_DN_sigma = np.sqrt(
    #    splitted_dara_arr / (gain * normalizing_S2)
    #    + sigma_S2
    #    * (splitted_dara_arr * splitted_dara_arr)
    #    / (normalizing_S2 * normalizing_S2)
    # )
    pix_DN_sigma = (
        np.sqrt(splitted_dara_arr / gain) / normalizing_S
    )  # poisson error on the photoelectrons

    normalized_splitted_data = splitted_dara_arr / normalizing_S
    all_zeros = np.zeros(shape=(num_of_points))

    m_ij = np.zeros(
        shape=(N_MALUS_PARAMS, N_PIXELS_IN_SUPERPIX, height, width)
    )  # demodulation matrix
    tk_data = np.ones(shape=(height, width)) * tk_prediction
    eff_data = np.ones(shape=(height, width)) * efficiency_prediction
    phase_data = np.zeros(shape=(height, width))
    superpix_params = np.zeros(shape=(N_PIXELS_IN_SUPERPIX, N_MALUS_PARAMS))

    predictions = np.zeros(shape=(N_PIXELS_IN_SUPERPIX, N_MALUS_PARAMS))
    predictions[:, 0] = tk_prediction  # Throughput prediction
    predictions[:, 1] = efficiency_prediction  # Efficiency prediction
    predictions[:, 2] = rad_micropol_phases_previsions  # Angle prediction

    bounds = np.zeros(shape=(N_PIXELS_IN_SUPERPIX, 2, N_MALUS_PARAMS))
    bounds[:, 0, 0], bounds[:, 1, 0] = 0.1, 0.9999999  # Throughput bounds

    # bounds[:, 0, 0], bounds[:, 1, 0] = (
    #    0.1,
    #    2.0,
    # )  # tk is multiplied by 0.5 so it can actually be &gt; 1 and still physical
    bounds[:, 0, 1], bounds[:, 1, 1] = 0.1, 0.9999999  # Efficiency bounds
    bounds[:, 0, 2] = rad_micropol_phases_previsions - 15  # Lower angle bounds
    bounds[:, 1, 2] = rad_micropol_phases_previsions + 15  # Upper angle bounds

    # Fit for each superpixel. Use theoretical demodulation matrix for
    # occulter if present.
    if DEBUG:
        x_start, x_end = 100, 110
        y_start, y_end = 100, 110
    else:
        y_start, y_end = 0, height
        x_start, x_end = 0, width
    milestones = [
        int(height / 4),
        int(height / 4) + 1,
        int(height / 2),
        int(height / 2) + 1,
        int(3 * height / 4),
        int(3 * height / 4) + 1,
        int(height),
        int(height) + 1,
    ]  # used for printing progress
    for super_y in range(y_start, y_end, 2):
        if super_y in milestones:
            print(f&#34;Thread at {super_y / height*100:.2f} %&#34;, flush=True)
        for super_x in range(x_start, x_end, 2):
            if not (
                np.any(
                    splitted_occulter_flag[
                        super_y : super_y + 2, super_x : super_x + 2
                    ]
                )
            ):
                normalized_superpix_arr = normalized_splitted_data[
                    :, super_y : super_y + 2, super_x : super_x + 2
                ].reshape(num_of_points, N_PIXELS_IN_SUPERPIX)

                sigma_pix = pix_DN_sigma[
                    :, super_y : super_y + 2, super_x : super_x + 2
                ].reshape(num_of_points, N_PIXELS_IN_SUPERPIX)
                sigma_pix = np.where(sigma_pix != 0.0, sigma_pix, 1.0e-5)

                for pixel_num in range(N_PIXELS_IN_SUPERPIX):
                    if np.array_equal(
                        normalized_superpix_arr[:, pixel_num], all_zeros
                    ):  # catch bad pixels
                        fit_success = False
                        break
                    try:
                        (
                            superpix_params[pixel_num],
                            superpix_pcov,
                        ) = curve_fit(
                            Malus,
                            polarizations_rad,
                            normalized_superpix_arr[:, pixel_num],
                            predictions[pixel_num],
                            sigma=sigma_pix[:, pixel_num],
                            bounds=bounds[pixel_num],
                        )
                        fit_success = True
                    except RuntimeError:
                        fit_success = False
                        break

                if DEBUG:  # DEBUG
                    colors = [&#34;blue&#34;, &#34;orange&#34;, &#34;green&#34;, &#34;red&#34;]
                    fig, ax = plt.subplots(
                        figsize=(9, 9), constrained_layout=True
                    )
                    for i in range(4):
                        ax.errorbar(
                            np.rad2deg(polarizations_rad),
                            normalized_superpix_arr[:, i],
                            yerr=sigma_pix[:, i],
                            xerr=[1.0] * len(polarizations_rad),
                            label=f&#34;points {i}&#34;,
                            fmt=&#34;k-&#34;,
                            color=colors[i],
                        )
                        min = np.min(polarizations_rad)
                        # min = 225
                        max = np.max(polarizations_rad)
                        # max = 405
                        x = np.arange(min, max, (max - min) / 100)
                        ax.plot(
                            np.rad2deg(x),
                            Malus(x, *superpix_params[i]),
                            label=f&#34;t = {superpix_params[i,0]:2.2f}, e = {superpix_params[i, 1]:2.2f}, phi = {np.rad2deg(superpix_params[i, 2]):2.2f}&#34;,
                            color=colors[i],
                        )
                        ax.set_title(
                            f&#34;super_y = {super_y}, super_x = {super_x},&#34;
                        )
                        ax.set_xlabel(&#34;Prepolarizer orientations [deg]&#34;)
                        ax.set_ylabel(&#34;signal / S&#34;)

                    plt.legend()
                    plt.show()

                if not fit_success:
                    for i in range(2):
                        for j in range(2):
                            m_ij[
                                :, :, super_y + i, super_x + j
                            ] = theo_demodulation_matrix
                    continue

                # Compute modulation matrix and its inverse
                t = superpix_params[:, 0]
                eff = superpix_params[:, 1]
                phi = superpix_params[:, 2]

                modulation_matrix = np.array(
                    [
                        0.5 * t,
                        0.5 * t * eff * np.cos(2.0 * phi),
                        0.5 * t * eff * np.sin(2.0 * phi),
                    ]
                )
                modulation_matrix = modulation_matrix.T
                demodulation_matrix = np.linalg.pinv(modulation_matrix)

                if DEBUG:
                    print()
                    print(&#34;MOD&#34;)
                    print(modulation_matrix)
                    print(theo_modulation_matrix)

                    print()
                    print(&#34;DEMOD&#34;)
                    print(demodulation_matrix)
                    print(theo_demodulation_matrix)

                    print()
                    print(&#34;params&#34;)
                    print(t)
                    print(eff)
                    print(phi)
                    print(&#34;---&#34;)

                # Remove matrices with big numbers
                if np.any(demodulation_matrix &gt; 100) or np.any(
                    demodulation_matrix &lt; -100
                ):
                    demodulation_matrix = theo_demodulation_matrix

                for i in range(2):
                    for j in range(2):
                        m_ij[
                            :, :, super_y + i, super_x + j
                        ] = demodulation_matrix

                tk_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(t).reshape(2, 2)
                eff_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(eff).reshape(2, 2)
                phase_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(phi).reshape(2, 2)

            else:  # pixel is in occulter region
                for i in range(2):
                    for j in range(2):
                        m_ij[
                            :, :, super_y + i, super_x + j
                        ] = theo_demodulation_matrix
                phase_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = rad_micropol_phases_previsions.reshape(2, 2)
                tk_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(
                    [
                        [tk_prediction, tk_prediction],
                        [tk_prediction, tk_prediction],
                    ]
                )
                eff_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(
                    [
                        [efficiency_prediction, efficiency_prediction],
                        [efficiency_prediction, efficiency_prediction],
                    ]
                )

    m_ij_chunk = m_ij

    return m_ij_chunk, tk_data, eff_data, phase_data


def Malus(angle, throughput, efficiency, phase):
    # original
    modulated_efficiency = efficiency * (
        np.cos(2.0 * phase) * np.cos(2.0 * angle)
        + np.sin(2.0 * phase) * np.sin(2.0 * angle)
    )
    return 0.5 * throughput * (1.0 + modulated_efficiency)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="micropolarray.processing.demodulation.Malus"><code class="name flex">
<span>def <span class="ident">Malus</span></span>(<span>angle, throughput, efficiency, phase)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Malus(angle, throughput, efficiency, phase):
    # original
    modulated_efficiency = efficiency * (
        np.cos(2.0 * phase) * np.cos(2.0 * angle)
        + np.sin(2.0 * phase) * np.sin(2.0 * angle)
    )
    return 0.5 * throughput * (1.0 + modulated_efficiency)</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.demodulation.calculate_demodulation_tensor"><code class="name flex">
<span>def <span class="ident">calculate_demodulation_tensor</span></span>(<span>polarizer_orientations, filenames_list, micropol_phases_previsions, gain, output_dir, binning=1, occulter=None, procs_grid=[4, 4], dark_filename=None, flat_filename=None, normalizing_S=None, DEBUG=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the demodulation tensor images and saves them. Requires a set of images with different polarizations to fit a Malus curve model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polarizer_orientations</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>List containing the orientations of the incoming light for each image.</dd>
<dt><strong><code>filenames_list</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>List of input images filenames to read. Must include [0, 45, 90, -45].</dd>
<dt><strong><code>micropol_phases_previsions</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>Previsions for the micropolarizer orientations required to initialize fit.</dd>
<dt><strong><code>gain</code></strong> :&ensp;<code>float</code></dt>
<dd>Detector [e-/DN], required to compute errors.</dd>
<dt><strong><code>output_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>output folder to save matrix to.</dd>
<dt><strong><code>binning</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Output matrices binning. Defaults to 1 (no binning). Be warned that binning matrices AFTER calculation is an incorrect operation.</dd>
<dt><strong><code>occulter</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>occulter y, x center and radius to exclude from calculations. Defaults to None.</dd>
<dt><strong><code>procs_grid</code></strong> :&ensp;<code>[int, int]</code>, optional</dt>
<dd>number of processors per side [Y, X], parallelization will be done in a Y x X grid. Defaults to [4,4] (16 procs in a 4x4 grid).</dd>
<dt><strong><code>dark_filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Dark image filename to correct input images. Defaults to None.</dd>
<dt><strong><code>flat_filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Flat image filename to correct input images. Defaults to None.</dd>
<dt><strong><code>normalizing_S</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>maximum signal used to normalize single pixel signal. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised if any among [0, 45, 90, -45] is not included in the input polarizations.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In the binning process the sum of values is considered, which is ok because data is normalized over the maximum S before being fitted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_demodulation_tensor(
    polarizer_orientations,
    filenames_list,
    micropol_phases_previsions,
    gain,  #  needed for errors
    output_dir,
    binning=1,
    occulter=None,
    procs_grid=[4, 4],
    dark_filename=None,
    flat_filename=None,
    normalizing_S=None,
    DEBUG=False,
):
    &#34;&#34;&#34;Calculates the demodulation tensor images and saves them. Requires a set of images with different polarizations to fit a Malus curve model.

    Args:
        polarizer_orientations (list[float]): List containing the orientations of the incoming light for each image.
        filenames_list (list[str]): List of input images filenames to read. Must include [0, 45, 90, -45].
        micropol_phases_previsions (list[float]): Previsions for the micropolarizer orientations required to initialize fit.
        gain (float): Detector [e-/DN], required to compute errors.
        output_dir (str): output folder to save matrix to.
        binning (int, optional): Output matrices binning. Defaults to 1 (no binning). Be warned that binning matrices AFTER calculation is an incorrect operation.
        occulter (list, optional): occulter y, x center and radius to exclude from calculations. Defaults to None.
        procs_grid ([int, int], optional): number of processors per side [Y, X], parallelization will be done in a Y x X grid. Defaults to [4,4] (16 procs in a 4x4 grid).
        dark_filename (str, optional): Dark image filename to correct input images. Defaults to None.
        flat_filename (str, optional): Flat image filename to correct input images. Defaults to None.
        normalizing_S (float, optional): maximum signal used to normalize single pixel signal. Defaults to None.

    Raises:
        ValueError: Raised if any among [0, 45, 90, -45] is not included in the input polarizations.

    Notes:
        In the binning process the sum of values is considered, which is ok because data is normalized over the maximum S before being fitted.
    &#34;&#34;&#34;

    correct_ifov = True

    # polarizations = array of polarizer orientations
    # filenames_list = list of filenames
    firstcall = True
    if (normalizing_S is None) and (
        not np.all(np.isin([0, 45, 90, -45], polarizer_orientations))
    ):
        raise ValueError(
            &#34;Each one among (0, 45, 90, -45) polarizations must be included in the polarizer orientation array&#34;
        )  # for calculating normalizing_S
    # Have to be sorted
    polarizer_orientations, filenames_list = (
        list(t)
        for t in zip(*sorted(zip(polarizer_orientations, filenames_list)))
    )
    micropol_phases_previsions = np.array(micropol_phases_previsions)
    rad_micropol_phases_previsions = np.deg2rad(micropol_phases_previsions)

    # Flag occulter position to not be fitted, expand to superpixel.
    with fits.open(filenames_list[0]) as file:
        data = file[0].data  # get data dimension

    print(&#34;qui&#34;)
    # Count binning before dimensions
    data = np.array(data, dtype=float)
    data = micropolarray_rebin(data, *data.shape, binning=binning)
    height, width = data.shape

    occulter_flag = np.ones_like(data)  # 0 if not a occulted px, 1 otherwise
    if occulter:
        # info(&#34;Cleaning occulter...&#34;)
        ## Mean values from coronal observations 2022_12_03
        ## (campagna_2022/mean_occulter_pos.py)
        # occulter_y, occulter_x, occulter_r = PolarCam().occulter_pos_last
        # overoccult = 16
        # overoccult = 0
        # occulter_r = occulter_r + overoccult

        # Match binning if needed
        binned_occulter = [int(val / binning) for val in occulter]
        occulter_y, occulter_x, occulter_r = binned_occulter

        occulter_flag = roi_from_polar(
            occulter_flag, [occulter_y, occulter_x], [0, occulter_r]
        )
        for super_y in range(0, occulter_flag.shape[0], 2):
            for super_x in range(0, occulter_flag.shape[1], 2):
                if np.any(
                    occulter_flag[super_y : super_y + 2, super_x : super_x + 2]
                ):
                    occulter_flag[
                        super_y : super_y + 2, super_x : super_x + 2
                    ] = 1
                    continue
    else:
        occulter_flag *= 0

    # Collect dark
    if dark_filename:
        with fits.open(dark_filename) as file:
            dark = np.array(file[0].data, dtype=np.float)
            dark = micropolarray_rebin(dark, *dark.shape, binning)
    # Collect flat field, normalize it
    if flat_filename:
        with fits.open(flat_filename) as file:
            flat = np.array(file[0].data, dtype=np.float)
        if correct_ifov:
            flat = ifov_jitcorrect(flat, *flat.shape)
        flat = micropolarray_rebin(flat, *flat.shape, binning)
        # flat_max = np.max(flat, axis=(0, 1))
        flat_max = mean_plus_std(flat, stds_n=1)
    if flat_filename and dark_filename:
        flat -= dark  # correct flat too
        flat = np.where(flat &gt; 0, flat, 1.0)
        if occulter:
            flat = np.where(occulter_flag, 1.0, flat)
        # flat_max = np.max(flat, axis=(0, 1))
        flat_max = mean_plus_std(flat, stds_n=1)
    if flat_filename:
        normalized_flat = np.where(occulter_flag, 1.0, flat / flat_max)

    # collect data
    all_data_arr = [0.0] * len(filenames_list)
    info(&#34;Collecting data from files...&#34;)
    for idx, filename in enumerate(filenames_list):
        with fits.open(filename) as file:
            all_data_arr[idx] = np.array(file[0].data, dtype=float)
            if correct_ifov:
                all_data_arr[idx] = ifov_jitcorrect(
                    all_data_arr[idx], *all_data_arr[idx].shape
                )
            all_data_arr[idx] = micropolarray_rebin(
                all_data_arr[idx], *all_data_arr[idx].shape, binning
            )
            if dark_filename is not None:
                all_data_arr[idx] -= dark
                all_data_arr[idx] = np.where(
                    all_data_arr[idx] &gt;= 0, all_data_arr[idx], 0.0
                )
            if flat_filename is not None:
                all_data_arr[idx] = np.divide(
                    all_data_arr[idx],
                    normalized_flat,
                    where=normalized_flat != 0.0,
                )
    all_data_arr = np.array(all_data_arr)

    if DEBUG:
        procs_grid = [1, 1]

    # parallelize into a procs_per_size x procs_per_size grid
    info(&#34;Splitting into subdomains to parallelize...&#34;)
    chunks_n_y, chunks_n_x = procs_grid
    chunk_size_y = int(height / chunks_n_y)
    chunk_size_x = int(width / chunks_n_x)
    if (chunk_size_x % 2) or (chunk_size_y % 2):
        raise ValueError(
            f&#34;cant decompose into a {procs_grid[0]}x{procs_grid[1]} grid (odd side grid {chunk_size_y}x{chunk_size_x}). Try changing the number of processors.&#34;
        )
    splitted_data = np.zeros(
        shape=(
            chunks_n_y * chunks_n_x,
            len(polarizer_orientations),
            chunk_size_y,
            chunk_size_x,
        )
    )
    splitted_occulter = np.zeros(
        shape=(chunks_n_y * chunks_n_x, chunk_size_y, chunk_size_x)
    )
    for i in range(chunks_n_y):
        for j in range(chunks_n_x):
            splitted_data[i + chunks_n_y * j] = np.array(
                all_data_arr[
                    :,
                    i * (chunk_size_y) : (i + 1) * chunk_size_y,
                    j * (chunk_size_x) : (j + 1) * chunk_size_x,
                ]
            )  # shape = (chunks_n*chunks_n, len(filenames_list), chunk_size_y, chunk_size_x)
            splitted_occulter[i + chunks_n_y * j] = np.array(
                occulter_flag[
                    i * (chunk_size_y) : (i + 1) * chunk_size_y,
                    j * (chunk_size_x) : (j + 1) * chunk_size_x,
                ]
            )  # shape = (chunks_n*chunks_n, chunk_size_y, chunk_size_x)

    if normalizing_S is None:
        info(&#34;Calculating normalization...&#34;)
        S_max = np.zeros(
            shape=(height, width)
        )  # tk_sum = tk_0 + tk_45 + tk_90 + tk_45
        for pol, image in zip(polarizer_orientations, all_data_arr):
            if pol in [0, 90, 45, -45]:
                S_max += 0.5 * image
        # Normalizing S, has a spike of which maximum is taken
        bins = 1000
        histo = np.histogram(S_max, bins=bins)
        maxvalue = np.max(histo[0])
        index = np.where(histo[0] == maxvalue)[0][0]
        normalizing_S = (
            histo[1][index] + histo[1][index + 1] + histo[1][index - 1]
        ) / 3
        # normalizing_S = np.max(S_max) # old

        # ----------------------------------------------
        # fit gaussian to S for normalization signal
        def gauss(x, norm, x_0, sigma):
            return norm * np.exp(-((x - x_0) ** 2) / (4 * sigma**2))

        hist_roi = 10  # bins around max value
        xvalues = np.array(histo[1])[index - hist_roi : index + hist_roi]
        yvalues = np.array(histo[0])[index - hist_roi : index + hist_roi]
        yvalues_sum = np.sum(yvalues)
        yvalues = yvalues / yvalues_sum
        xvalues = np.array(
            [value + (xvalues[1] - xvalues[0]) / 2 for value in xvalues]
        )  # shift each bin to center
        prediction = [
            yvalues[int(len(yvalues) / 2)],  # normalization
            xvalues[int(len(xvalues) / 2)],  # center
            xvalues[int(len(xvalues) / 2) + int(hist_roi / 2)]
            - xvalues[int(len(xvalues) / 2)],  # sigma
        ]
        params, cov = curve_fit(
            gauss,
            xvalues,
            yvalues,
            prediction,
        )
        normalizing_S = (
            params[1] + 4 * params[2]
        )  # center of gaussian + 2sigma
        # 3sigma -&gt; P = 2.7e-3 outliers
        # 4sigma -&gt; P = 6.3e-5 outliers
        # ----------------------------------------------
    else:
        normalizing_S *= binning * binning  # account binning

    # Debug
    if False:
        index = 0
        histo_0 = np.histogram(all_data_arr[index], bins=1000)
        fig, ax = plt.subplots(figsize=(9, 9))
        ax.stairs(histo_0[0], histo_0[1], label=&#34;sample image&#34;)
        ax.stairs(histo[0], histo[1], label=f&#34;S, max = {np.max(S_max)}&#34;)
        ax.axvline(normalizing_S, color=&#34;red&#34;, label=&#34;normalizing_S&#34;)
        # ax.plot(
        #    xvalues,
        #    gauss(xvalues, params[0] * yvalues_sum, params[1], params[2]),
        #    label=&#34;Fitted curve for normalizing S&#34;,
        # )
        ax.set_title(f&#34;Prepol at {polarizer_orientations[index]} deg&#34;)
        ax.set_xlabel(&#34;S [DN]&#34;)
        ax.set_ylabel(&#34;Counts&#34;)
        ax.legend()
        plt.show()
        sys.exit()

    args = (
        [
            splitted_data[i],
            normalizing_S,
            splitted_occulter[i],
            polarizer_orientations,
            rad_micropol_phases_previsions,
            gain,
            DEBUG,
        ]
        for i in range(chunks_n_y * chunks_n_x)
    )

    starting_time = time.perf_counter()
    loc_time = time.strftime(&#34;%H:%M:%S  (%Y/%m/%d)&#34;, time.localtime())
    info(
        f&#34;Starting parallel calculation ({procs_grid[0]}x{procs_grid[1]}) processors&#34;
    )

    if procs_grid != [1, 1]:
        try:
            with mp.Pool(processes=chunks_n_y * chunks_n_x) as p:
                result = p.starmap(
                    compute_demodulation_by_chunk,
                    args,
                )
        except:
            error(&#34;Fit not found&#34;)
            ending_time = time.perf_counter()

            info(f&#34;Elapsed : {(ending_time - starting_time)/60:3.2f} mins&#34;)
            sys.exit()

    else:
        arglist = [arg for arg in args]
        result = [[0.0, 0.0]] * chunks_n_y * chunks_n_x

        for i in range(chunks_n_y * chunks_n_x):
            result[i] = compute_demodulation_by_chunk(*arglist[i])

    loc_time = time.strftime(&#34;%H:%M:%S (%Y/%m/%d)&#34;, time.localtime())
    info(f&#34;Ending parallel calculation&#34;)

    ending_time = time.perf_counter()
    info(f&#34;Elapsed : {(ending_time - starting_time)/60:3.2f} mins&#34;)

    result = np.array(result)
    m_ij = np.zeros(
        shape=(N_MALUS_PARAMS, N_PIXELS_IN_SUPERPIX, height, width)
    )
    tks = np.zeros(shape=(height, width))
    efficiences = np.zeros(shape=(height, width))
    phases = np.zeros(shape=(height, width))

    for i in range(chunks_n_y):
        for j in range(chunks_n_x):
            m_ij[
                :,
                :,
                i * (chunk_size_y) : (i + 1) * chunk_size_y,
                j * (chunk_size_x) : (j + 1) * chunk_size_x,
            ] = result[i + chunks_n_y * j, 0].reshape(
                N_MALUS_PARAMS,
                N_PIXELS_IN_SUPERPIX,
                chunk_size_y,
                chunk_size_x,
            )
            tks[
                i * (chunk_size_y) : (i + 1) * chunk_size_y,
                j * (chunk_size_x) : (j + 1) * chunk_size_x,
            ] = result[i + chunks_n_y * j, 1].reshape(
                chunk_size_y, chunk_size_x
            )
            efficiences[
                i * (chunk_size_y) : (i + 1) * chunk_size_y,
                j * (chunk_size_x) : (j + 1) * chunk_size_x,
            ] = result[i + chunks_n_y * j, 2].reshape(
                chunk_size_y, chunk_size_x
            )
            phases[
                i * (chunk_size_y) : (i + 1) * chunk_size_y,
                j * (chunk_size_x) : (j + 1) * chunk_size_x,
            ] = result[i + chunks_n_y * j, 3].reshape(
                chunk_size_y, chunk_size_x
            )

    phases = np.rad2deg(phases)

    if DEBUG:
        # prevents overwriting
        sys.exit()

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    for i in range(N_MALUS_PARAMS):
        for j in range(N_PIXELS_IN_SUPERPIX):
            hdu = fits.PrimaryHDU(data=m_ij[i, j])
            hdu.writeto(output_dir + f&#34;M{i}{j}.fits&#34;, overwrite=True)
    hdu = fits.PrimaryHDU(data=tks)
    hdu.writeto(output_dir + &#34;transmittancies.fits&#34;, overwrite=True)
    hdu = fits.PrimaryHDU(data=efficiences)
    hdu.writeto(output_dir + &#34;efficiences.fits&#34;, overwrite=True)
    hdu = fits.PrimaryHDU(data=phases)
    hdu.writeto(output_dir + &#34;phases.fits&#34;, overwrite=True)

    info(&#34;Demodulation matrices and fit data successfully saved!&#34;)

    return</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.demodulation.compute_demodulation_by_chunk"><code class="name flex">
<span>def <span class="ident">compute_demodulation_by_chunk</span></span>(<span>splitted_dara_arr, normalizing_S, splitted_occulter_flag, polarizer_orientations, rad_micropol_phases_previsions, gain, DEBUG)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function to parallelize calculations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_demodulation_by_chunk(
    splitted_dara_arr,
    normalizing_S,
    splitted_occulter_flag,
    polarizer_orientations,
    rad_micropol_phases_previsions,
    gain,
    DEBUG,
):
    &#34;&#34;&#34;Utility function to parallelize calculations.&#34;&#34;&#34;
    N_MALUS_PARAMS = 3
    N_PIXELS_IN_SUPERPIX = 4
    # Preemptly compute the theoretical demo matrix to save time
    theo_modulation_matrix = np.array(
        [
            [0.5, 0.5, 0.5, 0.5],
            [
                0.5 * np.cos(2.0 * rad_micropol_phases_previsions[i])
                for i in range(N_PIXELS_IN_SUPERPIX)
            ],
            [
                0.5 * np.sin(2.0 * rad_micropol_phases_previsions[i])
                for i in range(N_PIXELS_IN_SUPERPIX)
            ],
        ]
    )
    theo_modulation_matrix = theo_modulation_matrix.T
    theo_demodulation_matrix = np.linalg.pinv(theo_modulation_matrix)

    num_of_points, height, width = splitted_dara_arr.shape
    rad_micropol_phases_previsions = np.array(rad_micropol_phases_previsions)
    polarizations_rad = np.deg2rad(polarizer_orientations)
    tk_prediction = 0.5
    efficiency_prediction = 0.4

    # Checked errors
    sigma_S2 = np.sqrt(0.5 * normalizing_S / gain)
    normalizing_S2 = normalizing_S * normalizing_S
    # pix_DN_sigma = np.sqrt(
    #    splitted_dara_arr / (gain * normalizing_S2)
    #    + sigma_S2
    #    * (splitted_dara_arr * splitted_dara_arr)
    #    / (normalizing_S2 * normalizing_S2)
    # )
    pix_DN_sigma = (
        np.sqrt(splitted_dara_arr / gain) / normalizing_S
    )  # poisson error on the photoelectrons

    normalized_splitted_data = splitted_dara_arr / normalizing_S
    all_zeros = np.zeros(shape=(num_of_points))

    m_ij = np.zeros(
        shape=(N_MALUS_PARAMS, N_PIXELS_IN_SUPERPIX, height, width)
    )  # demodulation matrix
    tk_data = np.ones(shape=(height, width)) * tk_prediction
    eff_data = np.ones(shape=(height, width)) * efficiency_prediction
    phase_data = np.zeros(shape=(height, width))
    superpix_params = np.zeros(shape=(N_PIXELS_IN_SUPERPIX, N_MALUS_PARAMS))

    predictions = np.zeros(shape=(N_PIXELS_IN_SUPERPIX, N_MALUS_PARAMS))
    predictions[:, 0] = tk_prediction  # Throughput prediction
    predictions[:, 1] = efficiency_prediction  # Efficiency prediction
    predictions[:, 2] = rad_micropol_phases_previsions  # Angle prediction

    bounds = np.zeros(shape=(N_PIXELS_IN_SUPERPIX, 2, N_MALUS_PARAMS))
    bounds[:, 0, 0], bounds[:, 1, 0] = 0.1, 0.9999999  # Throughput bounds

    # bounds[:, 0, 0], bounds[:, 1, 0] = (
    #    0.1,
    #    2.0,
    # )  # tk is multiplied by 0.5 so it can actually be &gt; 1 and still physical
    bounds[:, 0, 1], bounds[:, 1, 1] = 0.1, 0.9999999  # Efficiency bounds
    bounds[:, 0, 2] = rad_micropol_phases_previsions - 15  # Lower angle bounds
    bounds[:, 1, 2] = rad_micropol_phases_previsions + 15  # Upper angle bounds

    # Fit for each superpixel. Use theoretical demodulation matrix for
    # occulter if present.
    if DEBUG:
        x_start, x_end = 100, 110
        y_start, y_end = 100, 110
    else:
        y_start, y_end = 0, height
        x_start, x_end = 0, width
    milestones = [
        int(height / 4),
        int(height / 4) + 1,
        int(height / 2),
        int(height / 2) + 1,
        int(3 * height / 4),
        int(3 * height / 4) + 1,
        int(height),
        int(height) + 1,
    ]  # used for printing progress
    for super_y in range(y_start, y_end, 2):
        if super_y in milestones:
            print(f&#34;Thread at {super_y / height*100:.2f} %&#34;, flush=True)
        for super_x in range(x_start, x_end, 2):
            if not (
                np.any(
                    splitted_occulter_flag[
                        super_y : super_y + 2, super_x : super_x + 2
                    ]
                )
            ):
                normalized_superpix_arr = normalized_splitted_data[
                    :, super_y : super_y + 2, super_x : super_x + 2
                ].reshape(num_of_points, N_PIXELS_IN_SUPERPIX)

                sigma_pix = pix_DN_sigma[
                    :, super_y : super_y + 2, super_x : super_x + 2
                ].reshape(num_of_points, N_PIXELS_IN_SUPERPIX)
                sigma_pix = np.where(sigma_pix != 0.0, sigma_pix, 1.0e-5)

                for pixel_num in range(N_PIXELS_IN_SUPERPIX):
                    if np.array_equal(
                        normalized_superpix_arr[:, pixel_num], all_zeros
                    ):  # catch bad pixels
                        fit_success = False
                        break
                    try:
                        (
                            superpix_params[pixel_num],
                            superpix_pcov,
                        ) = curve_fit(
                            Malus,
                            polarizations_rad,
                            normalized_superpix_arr[:, pixel_num],
                            predictions[pixel_num],
                            sigma=sigma_pix[:, pixel_num],
                            bounds=bounds[pixel_num],
                        )
                        fit_success = True
                    except RuntimeError:
                        fit_success = False
                        break

                if DEBUG:  # DEBUG
                    colors = [&#34;blue&#34;, &#34;orange&#34;, &#34;green&#34;, &#34;red&#34;]
                    fig, ax = plt.subplots(
                        figsize=(9, 9), constrained_layout=True
                    )
                    for i in range(4):
                        ax.errorbar(
                            np.rad2deg(polarizations_rad),
                            normalized_superpix_arr[:, i],
                            yerr=sigma_pix[:, i],
                            xerr=[1.0] * len(polarizations_rad),
                            label=f&#34;points {i}&#34;,
                            fmt=&#34;k-&#34;,
                            color=colors[i],
                        )
                        min = np.min(polarizations_rad)
                        # min = 225
                        max = np.max(polarizations_rad)
                        # max = 405
                        x = np.arange(min, max, (max - min) / 100)
                        ax.plot(
                            np.rad2deg(x),
                            Malus(x, *superpix_params[i]),
                            label=f&#34;t = {superpix_params[i,0]:2.2f}, e = {superpix_params[i, 1]:2.2f}, phi = {np.rad2deg(superpix_params[i, 2]):2.2f}&#34;,
                            color=colors[i],
                        )
                        ax.set_title(
                            f&#34;super_y = {super_y}, super_x = {super_x},&#34;
                        )
                        ax.set_xlabel(&#34;Prepolarizer orientations [deg]&#34;)
                        ax.set_ylabel(&#34;signal / S&#34;)

                    plt.legend()
                    plt.show()

                if not fit_success:
                    for i in range(2):
                        for j in range(2):
                            m_ij[
                                :, :, super_y + i, super_x + j
                            ] = theo_demodulation_matrix
                    continue

                # Compute modulation matrix and its inverse
                t = superpix_params[:, 0]
                eff = superpix_params[:, 1]
                phi = superpix_params[:, 2]

                modulation_matrix = np.array(
                    [
                        0.5 * t,
                        0.5 * t * eff * np.cos(2.0 * phi),
                        0.5 * t * eff * np.sin(2.0 * phi),
                    ]
                )
                modulation_matrix = modulation_matrix.T
                demodulation_matrix = np.linalg.pinv(modulation_matrix)

                if DEBUG:
                    print()
                    print(&#34;MOD&#34;)
                    print(modulation_matrix)
                    print(theo_modulation_matrix)

                    print()
                    print(&#34;DEMOD&#34;)
                    print(demodulation_matrix)
                    print(theo_demodulation_matrix)

                    print()
                    print(&#34;params&#34;)
                    print(t)
                    print(eff)
                    print(phi)
                    print(&#34;---&#34;)

                # Remove matrices with big numbers
                if np.any(demodulation_matrix &gt; 100) or np.any(
                    demodulation_matrix &lt; -100
                ):
                    demodulation_matrix = theo_demodulation_matrix

                for i in range(2):
                    for j in range(2):
                        m_ij[
                            :, :, super_y + i, super_x + j
                        ] = demodulation_matrix

                tk_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(t).reshape(2, 2)
                eff_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(eff).reshape(2, 2)
                phase_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(phi).reshape(2, 2)

            else:  # pixel is in occulter region
                for i in range(2):
                    for j in range(2):
                        m_ij[
                            :, :, super_y + i, super_x + j
                        ] = theo_demodulation_matrix
                phase_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = rad_micropol_phases_previsions.reshape(2, 2)
                tk_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(
                    [
                        [tk_prediction, tk_prediction],
                        [tk_prediction, tk_prediction],
                    ]
                )
                eff_data[
                    super_y : super_y + 2, super_x : super_x + 2
                ] = np.array(
                    [
                        [efficiency_prediction, efficiency_prediction],
                        [efficiency_prediction, efficiency_prediction],
                    ]
                )

    m_ij_chunk = m_ij

    return m_ij_chunk, tk_data, eff_data, phase_data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="micropolarray.processing.demodulation.Demodulator"><code class="flex name class">
<span>class <span class="ident">Demodulator</span></span>
<span>(</span><span>demo_matrices_path:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Demodulation class needed for MicropolImage
demodulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Demodulator:
    &#34;&#34;&#34;Demodulation class needed for MicropolImage
    demodulation.&#34;&#34;&#34;

    def __init__(self, demo_matrices_path: str):
        self.n_pixels_in_superpix = N_PIXELS_IN_SUPERPIX
        self.n_malus_params = N_MALUS_PARAMS
        self.demo_matrices_path = demo_matrices_path

        self.mij = self._get_demodulation_tensor()

    def _get_demodulation_tensor(self):
        &#34;&#34;&#34;Reads files &#34;MIJ.fits&#34; from path folder and returns a (3,4,y,x)
        numpy array representing the demodulation tensor.

        Args:
            binning (bool, optional): _description_. Defaults to False.

        Raises:
            FileNotFoundError: couldn&#39;t find the matrices in the specified path

        Returns:
            ndarray: (3, 4, *data.shape) array containing the demodulation tensor
        &#34;&#34;&#34;

        if not os.path.exists(self.demo_matrices_path):
            raise FileNotFoundError(&#34;self.demo_matrices_path not found.&#34;)
        filenames_list = glob.glob(
            self.demo_matrices_path + os.path.sep + &#34;*.fits&#34;
        )

        with fits.open(filenames_list[0]) as firsthul:
            sample_data = np.array(firsthul[0].data)
        Mij = np.zeros(
            shape=(
                self.n_malus_params,
                self.n_pixels_in_superpix,
                sample_data.shape[0],
                sample_data.shape[1],
            ),
            dtype=float,
        )

        matches = 0
        for filename in filenames_list:
            if (
                re.search(&#34;[Mm][0-9]{2}&#34;, filename.split(os.path.sep)[-1])
                is not None
            ):  # Exclude files not matching m/Mij
                matches += 1
                i, j = re.search(
                    &#34;[Mm][0-9]{2}&#34;, filename.split(os.path.sep)[-1]
                ).group()[
                    -2:
                ]  # Searches for pattern M/m + ij as last string before .fits
                i = int(i)
                j = int(j)
                with fits.open(filename) as hul:
                    Mij[i, j] = hul[0].data
        if matches != 12:
            raise ValueError(
                &#34;Some matrices were not found in the selected folder. Check correct folder name and files pattern Mij.fits or mij.fits&#34;
            )

        return Mij

    def show(self, vmin=-1, vmax=1, cmap=&#34;Greys&#34;) -&gt; tuple:
        &#34;&#34;&#34;Shows the demodulation tensor

        Args:
            vmin (int, optional): Minimum shown value. Defaults to -1.
            vmax (int, optional): Maximum shown value. Defaults to 1.
            cmap (str, optional): Colormap of the plot. Defaults to &#34;Greys&#34;.

        Returns:
            tuple: fig, ax tuple as returned by matplotlib.pyplot.subplots
        &#34;&#34;&#34;
        fig, ax = plt.subplots(
            3,
            4,
            dpi=300,
            figsize=(4, 3),
            constrained_layout=True,
            sharex=&#34;col&#34;,
            sharey=&#34;row&#34;,
        )
        for i in range(3):
            for j in range(4):
                mappable = ax[i, j].imshow(
                    self.mij[i, j], cmap=cmap, vmin=vmin, vmax=vmax
                )
                ax[i, j].set_title(rf&#34;M$_{i}$$_{j}$&#34;)
        for ax in fig.get_axes():
            ax.label_outer()

        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(mappable, cax=cbar_ax)

        return fig, ax

    def rebin(self, binning):  # TODO
        &#34;&#34;&#34;DO NOT USE THIS, calculate the tensor from the binned images&#34;&#34;&#34;
        if (int(self.mij.shape[2] / binning) % 2) or (
            int(self.mij.shape[3] / binning) % 2
        ):
            raise ValueError(
                f&#34;incorrect binning, resulting matrix would be {int(self.mij.shape[2] / binning)}x{int(self.mij.shape[3] / binning)} (not even values).&#34;
            )
        new_demodulator = Demodulator(self.demo_matrices_path)
        new_mij = np.zeros(
            shape=(
                new_demodulator.n_malus_params,
                new_demodulator.n_pixels_in_superpix,
                int(new_demodulator.mij.shape[2] / binning),
                int(new_demodulator.mij.shape[3] / binning),
            )
        )
        for j in range(new_demodulator.n_malus_params):
            for i in range(new_demodulator.n_pixels_in_superpix):
                new_mij[j, i] = standard_rebin(
                    new_demodulator.mij[j, i], binning
                ) / (binning * binning)
        new_demodulator.mij = new_mij

        return new_demodulator

    def rot90(self, k=1):
        # NB: rotation could switch micropol positions inside superpixel, but for demo matrix all px in superpix are equal
        for i in range(self.n_malus_params):
            for j in range(self.n_pixels_in_superpix):
                self.mij[i, j] = np.rot90(self.mij[i, j], k=k)

    def flip(self, axis):
        for i in range(self.n_malus_params):
            for j in range(self.n_pixels_in_superpix):
                self.mij[i, j] = np.flip(self.mij[i, j], axis=axis)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="micropolarray.processing.demodulation.Demodulator.flip"><code class="name flex">
<span>def <span class="ident">flip</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip(self, axis):
    for i in range(self.n_malus_params):
        for j in range(self.n_pixels_in_superpix):
            self.mij[i, j] = np.flip(self.mij[i, j], axis=axis)</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.demodulation.Demodulator.rebin"><code class="name flex">
<span>def <span class="ident">rebin</span></span>(<span>self, binning)</span>
</code></dt>
<dd>
<div class="desc"><p>DO NOT USE THIS, calculate the tensor from the binned images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rebin(self, binning):  # TODO
    &#34;&#34;&#34;DO NOT USE THIS, calculate the tensor from the binned images&#34;&#34;&#34;
    if (int(self.mij.shape[2] / binning) % 2) or (
        int(self.mij.shape[3] / binning) % 2
    ):
        raise ValueError(
            f&#34;incorrect binning, resulting matrix would be {int(self.mij.shape[2] / binning)}x{int(self.mij.shape[3] / binning)} (not even values).&#34;
        )
    new_demodulator = Demodulator(self.demo_matrices_path)
    new_mij = np.zeros(
        shape=(
            new_demodulator.n_malus_params,
            new_demodulator.n_pixels_in_superpix,
            int(new_demodulator.mij.shape[2] / binning),
            int(new_demodulator.mij.shape[3] / binning),
        )
    )
    for j in range(new_demodulator.n_malus_params):
        for i in range(new_demodulator.n_pixels_in_superpix):
            new_mij[j, i] = standard_rebin(
                new_demodulator.mij[j, i], binning
            ) / (binning * binning)
    new_demodulator.mij = new_mij

    return new_demodulator</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.demodulation.Demodulator.rot90"><code class="name flex">
<span>def <span class="ident">rot90</span></span>(<span>self, k=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot90(self, k=1):
    # NB: rotation could switch micropol positions inside superpixel, but for demo matrix all px in superpix are equal
    for i in range(self.n_malus_params):
        for j in range(self.n_pixels_in_superpix):
            self.mij[i, j] = np.rot90(self.mij[i, j], k=k)</code></pre>
</details>
</dd>
<dt id="micropolarray.processing.demodulation.Demodulator.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, vmin=-1, vmax=1, cmap='Greys') >tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the demodulation tensor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vmin</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Minimum shown value. Defaults to -1.</dd>
<dt><strong><code>vmax</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum shown value. Defaults to 1.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Colormap of the plot. Defaults to "Greys".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>fig, ax tuple as returned by matplotlib.pyplot.subplots</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, vmin=-1, vmax=1, cmap=&#34;Greys&#34;) -&gt; tuple:
    &#34;&#34;&#34;Shows the demodulation tensor

    Args:
        vmin (int, optional): Minimum shown value. Defaults to -1.
        vmax (int, optional): Maximum shown value. Defaults to 1.
        cmap (str, optional): Colormap of the plot. Defaults to &#34;Greys&#34;.

    Returns:
        tuple: fig, ax tuple as returned by matplotlib.pyplot.subplots
    &#34;&#34;&#34;
    fig, ax = plt.subplots(
        3,
        4,
        dpi=300,
        figsize=(4, 3),
        constrained_layout=True,
        sharex=&#34;col&#34;,
        sharey=&#34;row&#34;,
    )
    for i in range(3):
        for j in range(4):
            mappable = ax[i, j].imshow(
                self.mij[i, j], cmap=cmap, vmin=vmin, vmax=vmax
            )
            ax[i, j].set_title(rf&#34;M$_{i}$$_{j}$&#34;)
    for ax in fig.get_axes():
        ax.label_outer()

    fig.subplots_adjust(right=0.8)
    cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
    fig.colorbar(mappable, cax=cbar_ax)

    return fig, ax</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="micropolarray.processing" href="index.html">micropolarray.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="micropolarray.processing.demodulation.Malus" href="#micropolarray.processing.demodulation.Malus">Malus</a></code></li>
<li><code><a title="micropolarray.processing.demodulation.calculate_demodulation_tensor" href="#micropolarray.processing.demodulation.calculate_demodulation_tensor">calculate_demodulation_tensor</a></code></li>
<li><code><a title="micropolarray.processing.demodulation.compute_demodulation_by_chunk" href="#micropolarray.processing.demodulation.compute_demodulation_by_chunk">compute_demodulation_by_chunk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="micropolarray.processing.demodulation.Demodulator" href="#micropolarray.processing.demodulation.Demodulator">Demodulator</a></code></h4>
<ul class="">
<li><code><a title="micropolarray.processing.demodulation.Demodulator.flip" href="#micropolarray.processing.demodulation.Demodulator.flip">flip</a></code></li>
<li><code><a title="micropolarray.processing.demodulation.Demodulator.rebin" href="#micropolarray.processing.demodulation.Demodulator.rebin">rebin</a></code></li>
<li><code><a title="micropolarray.processing.demodulation.Demodulator.rot90" href="#micropolarray.processing.demodulation.Demodulator.rot90">rot90</a></code></li>
<li><code><a title="micropolarray.processing.demodulation.Demodulator.show" href="#micropolarray.processing.demodulation.Demodulator.show">show</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>